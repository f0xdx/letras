/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.net;

import java.io.IOException;
import org.mundo.rt.Service;
import org.mundo.rt.TypedMap;
import org.mundo.rt.Message;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.ProtocolStack;
import org.mundo.net.transport.TransportLink;

/**
 * This is a helper class for implementing custom protocol handlers.
 * The forwarding methods <code>emit_down</code> and <code>emit_up</code>
 * allow to implement protocol handlers without using <code>mcc</code>.
 * 
 * @author Erwin Aitenbichler
 */
public abstract class AbstractHandler extends Service implements IMessageHandler emits IMessageHandler
{
  /**
   * Adds the specified header to the message.
   * @param msg  the target message.
   * @param name  the name of the header chunk.
   * @param map  the map containing the header.
   * @throws IOException  in case that header fields cannot be passivated or serialized.
   */
  public static void putHeader(Message msg, String name, TypedMap map) throws IOException
  {
    BinSerializer ser = new BinSerializer();
    msg.put(name, "bin", ser.serialize(map));
  }
  /**
   * Retrieves the header with the specified name from the message.
   * @param msg  the source message.
   * @param name  the name of the header chunk.
   * @return  the map containing the header.
   * @throws IOException  in case that header fields cannot be deserialized or activated.
   */
  public static TypedMap getHeader(Message msg, String name) throws IOException
  {
    BinDeserializer deser = new BinDeserializer();
    return (TypedMap)deser.deserialize(msg.getBlob(name, "bin"));
  }
  /**
   * Sends down a reply message.
   */
  public boolean sendReply(Message msg, Message reply)
  {
    // Get the route from the source message
    TransportLink link = getLink(msg);

    // Apply the same route to the destination message
    TypedMap ts = new TypedMap();
    ts.put("link", link);
    reply.put("ts", "param", ts);

    // Use the default protocol stack and send the reply message
    reply.setStack(ProtocolCoordinator.getInstance().getDefaultStack(), getClass());
    return emit.down(reply);
  }
  /**
   * Retrieves the associated route object.
   */
  public TransportLink getLink(Message msg)
  {
    TypedMap tsmap = msg.getMap("ts", "param");
    if (tsmap == null)
      throw new IllegalArgumentException("missing parameters ts:param from transport service");
    return (TransportLink)tsmap.getObject("link");
  }
  /**
   * Passes the specified message to the next lower handler.
   */
  protected boolean emit_down(Message msg)
  {
    return emit.down(msg);
  }
  /**
   * Passes the specified message to the next higher handler.
   */
  protected boolean emit_up(Message msg)
  {
    return emit.up(msg);
  }
}
