/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.net;

#ifdef CFG_CHECKED_BUILD
#  define LOG log
#else
#  define LOG //
#endif

#ifdef CFG_JAVA15
import org.mundo.annotation.*;
#endif

#ifndef CFG_CLDC
import java.util.ArrayList;
#endif
import java.util.Hashtable;

import org.mundo.rt.IActivate;
import org.mundo.rt.IBCLProvider;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.Message;
import org.mundo.rt.MessageContext;
import org.mundo.rt.Subscriber;
import org.mundo.rt.Publisher;
import org.mundo.rt.Service;
import org.mundo.rt.Session;
import org.mundo.rt.Signal;
import org.mundo.rt.Mundo;
import org.mundo.rt.ProtocolStack;
import org.mundo.rt.TypedArray;
import org.mundo.rt.TypedMap;
import org.mundo.rt.Channel;
import org.mundo.rt.Logger;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.IProtocolCondition;

/**
 * This service forwards local messages to the first routing service
 * in the protocol stack.
 */
public class ProtocolCoordinator
       extends Service
       implements IBCLProvider.ISignal, IMessageHandler
{
  /**
   * Options to configure node discovery.
   */
  @mcSerialize(className="ProtocolCoordinator$Options")
  public static class Options implements IActivate
  {
    /**
     * The name of the default protocol stack.
     */
    @mcField(name="default-stack")
    public String   defaultStack;
    /**
     * The protocol stacks.
     */
    @mcField(name="stacks")
    public TypedMap stacks;
  }

  /**
   * Initializes a new <code>ProtocolCoordinator</code>.
   */
  public ProtocolCoordinator()
  {
    instance = this;
  }
  /**
   * Returns the singleton instance of ProtocolCoordinator.
   */
  public static ProtocolCoordinator getInstance()
  {
    return instance;
  }
  /**
   * Sets configuration options for this service.
   */
  @Override
  public void setServiceConfig(Object cfg)
  {
    if (conf!=null)
      throw new IllegalStateException("reconfiguration not supported");
    conf=(Options)cfg;
  }

  /**
   * Returns the configuration options for this service.
   */
  @Override
  public Object getServiceConfig()
  {
    return conf;
  }
  /**
   * Returns the protocol stack with the specified name.
   */
  public ProtocolStack getStack(String name)
  {
    try
    {
      //FIXME: better way to fix up/down-links?
      return new ProtocolStack(new ProtocolStack(parseArray(conf.stacks.getArray(name))));
    }
    catch(Exception x)
    {
      log.exception(x);
      throw new IllegalArgumentException("unknown or broken protocol stack: "+name);
    }
  }
  /**
   * Returns the default protocol stack.
   */
  public ProtocolStack getDefaultStack()
  {
    if (defaultStack == null)
      throw new IllegalStateException("no default stack defined");
    return defaultStack;
  }
  /**
   * Initializes the service.
   */
  @Override
  public void init() // Service
  {
    setState(STATE_INITIALIZING);
    if (conf==null)
      conf = new Options();
    if (conf.defaultStack!=null)
    {
      LOG.fine("initializing default stack");
      try
      {
        //FIXME: the only way to create a correctly linked stack seems to be the copy constructor.
        defaultStack = new ProtocolStack(new ProtocolStack(
            parseArray(conf.stacks.getArray(conf.defaultStack))));
      }
#ifdef CFG_CHECKED_BUILD
      catch(ClassNotFoundException x)
      {
        log.severe("unknown handler in default stack: "+x.toString());
      }
#endif
      catch(Exception x)
      {
        log.exception(x);
      }
    }
    if (conf.defaultStack==null)
      log.warning("no default stack defined");
    
    // watch new subscriptions in the local runtime
    Signal.connect("rt", IBCLProvider.ISignal.class, this);

    // connect to outputs of message handlers
    Signal.connect("rt", IMessageHandler.class, this);
    setState(STATE_INITIALIZED);
  }

#ifndef CFG_CLDC 
#ifdef CFG_JAVA15
  private ArrayList<ProtocolStack.Handler> parseArray(TypedArray a) throws
          ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    ArrayList<ProtocolStack.Handler> list = new ArrayList<ProtocolStack.Handler>();
#else
  private ArrayList parseArray(TypedArray a) throws
          ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    ArrayList list = new ArrayList();
#endif
    int i, s=a.size();
    for (i=0; i<s; i++)
    {
      Object obj = a.get(i);
      if (obj instanceof String)
        list.add(new ProtocolStack.Handler(Class.forName((String)obj), new TypedMap()));
      else if (obj instanceof TypedMap)
      {
        TypedMap map = (TypedMap)obj;
        if (map.containsKey("condition"))
          list.add(parseIf((TypedMap)obj));
        else if (map.containsKey("class"))
        {
          list.add(new ProtocolStack.Handler(
              Class.forName(map.getString("class")),
              map.getMap("options", null) ));
        }
      }
    }
    return list;
  }
#else
  private TypedArray parseArray(TypedArray a) throws
          ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    TypedArray list = new TypedArray();
    int i, s=a.size();
    for (i=0; i<s; i++)
    {
      Object obj = a.get(i);
      if (obj instanceof String)
      {
        LOG.fine("add handler "+obj);
        list.add(new ProtocolStack.Handler(Class.forName((String)obj), new TypedMap()));
      }
      else if (obj instanceof TypedMap)
      {
        TypedMap map = (TypedMap)obj;
        if (map.containsKey("condition"))
          list.add(parseIf((TypedMap)obj));
        else if (map.containsKey("class"))
        {
          list.add(new ProtocolStack.Handler(
              Class.forName(map.getString("class")),
              map.getMap("options", null) ));
        }
      }
    }
    return list;
  }
#endif
  
  private ProtocolStack.Handler parseIf(TypedMap map) throws
          ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    IProtocolCondition cond = (IProtocolCondition)Class.forName(
        map.getString("condition")).newInstance();
    ProtocolStack.BranchHandler handler = new ProtocolStack.BranchHandler(cond);

    handler.setThen(parseArray(map.getArray("then")));
    handler.setElse(parseArray(map.getArray("else")));

    return handler;
  }
  
  public void publisherAdded(Publisher p) /* IBCLProvider.ISignal */
  {
    if (p.getChannel().getZone().equals("rt"))
      return;
    if (responsibleZone!=null && !p.getChannel().getZone().equals(responsibleZone))
      return;
    storeChannel(p.getChannel());
    getBroker(p.getChannel().getStack()).publisherAdded(p);
  }
  public void publisherRemoved(Publisher p)  /* IBCLProvider.ISignal */
  {
    getBroker(p.getChannel().getStack()).publisherRemoved(p);
  }
  public void subscriberAdded(Subscriber s) /* IBCLProvider.ISignal */
  {
    if (s.getChannel().getZone().equals("rt"))
      return;
    if (responsibleZone!=null && !s.getChannel().getZone().equals(responsibleZone))
      return;
    storeChannel(s.getChannel());
    getBroker(s.getChannel().getStack()).subscriberAdded(s);
  }
  public void subscriberRemoved(Subscriber s) /* IBCLProvider.ISignal */
  {
    getBroker(s.getChannel().getStack()).subscriberRemoved(s);
  }
  /**
   * Returns the first message broker in the stack.
   */
  private IBCLProvider.ISignal getBroker(ProtocolStack stack)
  {
    for (int i=0; i<stack.size(); i++)
    {
      Object obj=stack.get(i).getMsgHandler();
      if (obj instanceof IBCLProvider.ISignal)
        return (IBCLProvider.ISignal)obj;
    }
    return null;
  }
  /**
   * Forwards the specified message downwards to the first protocol handler.
   */
  public boolean firstDown(Message msg)
  {
#ifdef CFG_CHECKED_BUILD
    int hc = msg.hashCode();
    ProtocolStack.Handler h = msg.getHandler().forMsg(msg);
    boolean success = h.getMsgHandler().down(msg);
    if (msg.hashCode() != hc)
    {
      log.severe("firstDown: illegal modification of message by handler "+h.getMsgHandler());
    }
    return success;
#else
    return msg.getHandler().forMsg(msg).getMsgHandler().down(msg);
#endif
  }
  /**
   * Forwards the specified message downwards to the next protocol handler.
   */
  public boolean down(Message msg) // IMessageHandler
  {
    try
    {
      while (state < STATE_INITIALIZED)
        Thread.sleep(100);
    }
    catch(InterruptedException x)
    {
      LOG.severe("received interrupt signal during init");
      return false;
    }
    ProtocolStack.Handler h = msg.getHandler();
    if (h==null)
      throw new IllegalArgumentException("no message handler specified in message");
    h = h.nextDown().forMsg(msg);
    if (h==null)
      throw new IllegalArgumentException("no more handlers");
    Message dmsg = msg.copyFrame();
    dmsg.setHandler(h);
#ifdef CFG_CHECKED_BUILD
    int hc = msg.hashCode();
    boolean success = h.getMsgHandler().down(dmsg);
    if (msg.hashCode() != hc)
      log.severe("down: illegal modification of message by handler "+h.getMsgHandler());
    return success;
#else
    return h.getMsgHandler().down(dmsg);
#endif
  }
  /**
   * Forwards the specified message upwards to the next protocol handler.
   */
  public boolean up(Message msg) // IMessageHandler
  {
    try
    {
      while (state < STATE_INITIALIZED)
        Thread.sleep(100);
    }
    catch(InterruptedException x)
    {
      LOG.severe("received interrupt signal during init");
      return false;
    }
    IMessageHandler handler;

    TypedMap amap = msg.getMap("address", "passive");
    if (amap==null)
    {
      log.severe("message does not contain an address map");
      return false;
    }

    // Use the protocol stack if we already know the channel
    String channelName = amap.getString("channel", null);
    if (channelName!=null)
    {
      LOG.finest("up: channelName="+channelName);
      if (msg.getStack()==null)
      {
        SMEntry sme = (SMEntry)stackMap.get(channelName);
#ifdef CFG_CHECKED_BUILD
        if (sme==null)
        {
          LOG.warning("up: no stack found for channel: "+channelName);
          return false;
        }
#endif
        msg.setStack(sme.ps, sme.psh);
      }

      ProtocolStack.Handler mh = msg.getHandler().nextUp();
      LOG.finest("up (linear): handler={"+mh+"}");
      if (mh!=null)
      {
        msg.setHandler(mh);
        return mh.getMsgHandler().up(msg);
      }
      Mundo.bcl.send(new Channel("rt", channelName), msg, (Session)amap.get("session"));
      return true;
    }

    // Use the MIME type otherwise
    handler = (IMessageHandler)upMap.get(amap.getString("mimeType"));
    LOG.finest("up (type): handler={"+handler+"}");
    if (handler==null)
    {
      log.warning("up (type): no handler for: "+amap.getString("mimeType")+" - msg dropped");
#ifdef CFG_CHECKED_BUILD
      LOG.finest(msg.toString());
#endif
      return false;
    }
//    System.out.println("handler="+handler);
    return handler.up(msg);
  }
  /**
   *
   */
  public static void register(String mimeType, IMessageHandler handler)
  {
    upMap.put(mimeType, handler);
  }
  /**
  *
  */
  public boolean registerChannel(Channel ch, Class c)
  {
    ProtocolStack ps = ch.getStack();
    if (ps!=null)
    {
      ProtocolStack.Handler h = ps.findHandler(c);
      if (h!=null)
      {
        stackMap.put(ch.getName(), new SMEntry(ps, h));
        return true;
      }
    }
    return false;
  }
  /**
   *
   */
  private void storeChannel(Channel ch)
  {
    ProtocolStack ps = ch.getStack();
    if (ps!=null)
    {
      ProtocolStack.Handler h = ps.findHandler(IBCLProvider.ISignal.class);
      if (h!=null)
        stackMap.put(ch.getName(), new SMEntry(ps, h));
      else
      {
        log.warning("stack for "+ch.getName()+" does not contain a message broker");
        log.warning("stack: "+ps);
      }
    }
  }
  
  class SMEntry
  {
    ProtocolStack ps;
    ProtocolStack.Handler psh;
    
    SMEntry(ProtocolStack ps, ProtocolStack.Handler psh)
    {
      this.ps = ps;
      this.psh = psh;
    }
  }

  private static ProtocolCoordinator instance = null;
  private ProtocolStack defaultStack;
  private Options conf;
  private String responsibleZone = null;
  private Logger log = Logger.getLogger("pc");
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
  private static Hashtable<String,IMessageHandler> upMap = new Hashtable<String,IMessageHandler>();
  private static Hashtable<String,SMEntry> stackMap = new Hashtable<String,SMEntry>();
#else
  private static Hashtable upMap = new Hashtable();
  private static Hashtable stackMap = new Hashtable();
#endif
#else
  private static Hashtable upMap = new Hashtable();
  private static Hashtable stackMap = new Hashtable();
#endif
}
