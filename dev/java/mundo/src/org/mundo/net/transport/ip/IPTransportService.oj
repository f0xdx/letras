/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.net.transport.ip;

//#define TRACE_MODULE

import org.mundo.annotation.*;
import org.mundo.rt.Mundo;
import org.mundo.rt.Blob;
import org.mundo.rt.RootService;
import org.mundo.rt.Service;
import org.mundo.rt.GUID;
import org.mundo.rt.Signal;
import org.mundo.rt.Message;
import org.mundo.rt.TypedMap;
import org.mundo.rt.TypedArray;
import org.mundo.rt.IActivate;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.Semaphore;
import org.mundo.rt.Logger;
import org.mundo.net.ISerialize;
import org.mundo.net.BinSerializationHandler;
import org.mundo.net.transport.ITransportService;
import org.mundo.net.transport.TransportLink;

import java.io.OutputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.DatagramSocket;
import java.net.DatagramSocketImpl;
import java.net.MulticastSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.ConnectException;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Vector;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.NoSuchElementException;
#ifndef CFG_J2ME
import java.net.Inet4Address;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
#endif

#ifdef CFG_CHECKED_BUILD
#  define LOG log
#else
#  define LOG //
#endif
#ifdef CFG_XML
import org.mundo.xml.XMLSerializationHandler;
#endif
#ifdef TRACE_MODULE
import org.mundo.rt.Tracer;
#  define TRACE trace.before
#else
#  define TRACE //
#endif

/**
 * <p>Implements a transport service based on IP. It uses TCP connections
 * to transport messages, and UDP datagrams to discover nodes in the same
 * subnet. The automatic discovery mechanism is quite powerful, but it
 * is not trivial and requires proper configuration.</p>
 *
 * <p><b>Local Discovery:</b>
 * In the default configuration, MundoCore only connects to processes
 * on the local machine. Local discovery works as follows: MundoCore
 * guarantees that if at least one node is run on a host, then any of
 * these nodes is listening on the primary port. Nodes started in addition
 * can then connect to this primary port and get information about all other
 * neighbours from the process there. If the process holding the primary
 * port goes down, another process immediately tries to allocate it.</p>
 *
 * <p><b>Discovery in the local subnet:</b>
 * To discover other nodes in the same subnet, UDP broadcast-based
 * discovery can be used. This option has to be explicitly enabled in the
 * configuration file.</p>
 *
 * This service supports the profiles J2SE and CDC, but not CLDC.
 *
 * @see org.mundo.rt.Mundo
 * @author Erwin Aitenbichler
 */
public final class IPTransportService
       extends Service
       implements ITransportService, IMessageHandler
       emits ITransportService.IConn, IMessageHandler
{
  /**
   * Options to configure node discovery.
   */
  @mcSerialize(className="IPTransportService$OptDiscovery")
  public static class OptDiscovery implements IActivate
  {
    /**
     * Enables connect to the local primary port. (default: true)
     */
    @mcField(name="connect-primary", optional=true)
    public Boolean              connectToPrimary;
    /**
     * Enables sending of neighbors messages. (default: true)
     */
    @mcField(name="send-neighbors", optional=true)
    public Boolean              sendNeighbors;
    /**
     * An attribute string describing the capabilities of this node.
     */
    @mcField(optional=true)
    public String               attributes;
    /**
     * If defined, this node will only connect to other nodes that have the
     * specified required attribute.
     */
    @mcField(name="require-attribute", optional=true)
    public String               requiredAttribute;
  }

  /**
   * Options to configure broadcast discovery.
   */
  @mcSerialize(className="IPTransportService$OptNet")
  public static class OptNet implements IActivate
  {
    /**
     * The broadcast address to use on the interface. If this field is omitted,
     * the associated netmask specifies the default netmask.
     */
    @mcField(name="broadcast", optional=true)
    public String               broadcast;
    /**
     * The netmask to use on the interface.
     */
    public String               netmask;
  }

  /**
   * Options to configure node discovery.
   */
  @mcSerialize(className="IPTransportService$OptBroadcast")
  public static class OptBroadcast implements IActivate
  {
    /**
     * Enables sending of broadcast discovery messages. (default: false)
     */
    @mcField(name="send", optional=true)
    public Boolean              send;
    /**
     * Enables receiving of broadcast discovery messages. (default: false)
     */
    @mcField(name="answer", optional=true)
    public Boolean              answer;
    /**
     * Interval for sending broadcast discovery messages in seconds. (default: 30)
     */
    public Integer              interval;
    /**
     * A list of interfaces to send broadcast discovery messages on. (default: none)
     */
    public TypedArray           nets;
  }

  /**
   * Options to configure IP Multicast discovery.
   */
  @mcSerialize(className="IPTransportService$OptMulticast")
  public static class OptMulticast implements IActivate
  {
    /**
     * The multicast group address. (default: 239.255.255.42)
     */
    public String               group;
    /**
     * The multicast port number. (default: 4241)
     */
    @mcField(optional=true)
    public Integer              port;
    /**
     * Sets the time-to-live. (default: 0)
     */
    @mcField(optional=true)
    public Integer              ttl;
    /**
     * Enables sending of multicast discovery messages.
     */
    @mcField(optional=true)
    public Boolean              send;
    /**
     * Enables answering of multicast discovery messages.
     */
    @mcField(optional=true)
    public Boolean              answer;
    /**
     * Interval for sending multicast discovery messages in seconds. (default: 30)
     */
    @mcField(optional=true)
    public Integer              interval;

    private transient InetAddress groupAddr;
  }

  /**
   * Options to open a connection to a specific host.
   */
  @mcSerialize(className="IPTransportService$OptHost")
  public static class OptHost implements IActivate
  {
    /**
     * The hostname or IP address of the remote peer.
     */
    public String               name;
    /**
     * The port number on the remote peer.
     */
    public Integer              port;
    /**
     * Retry interval. (default: disabled)
     */
    @mcField(name="retry-interval", optional=true)
    public Integer              retryInterval;
    /**
     * Retry interval if this node doesn't have any connections open. (default: disabled)
     */
    @mcField(name="disconnected-retry-interval", optional=true)
    public Integer              disconnectedRetryInterval;
    
    transient long lastRetry=0;
  }

  /**
   * Options to configure the service.
   */
  @mcSerialize(className="IPTransportService$Options")
  public static class Options implements IActivate
  {
    /**
     * The <em>primary port number</em>. (default: 4242)
     */
    @mcField(name="primary-port")
    public Integer              primaryPort;
    /**
     * Selects the transport protocol (default: <code>bin</code>).
     */
    @mcField(optional=true)
    public String               protocol;
    /**
     * Enables TCP server (default: <code>true</code>).
     */
    @mcField(name="tcp-server", optional=true)
    public Boolean              tcpServer;
    /**
     * Enables UDP server (default: <code>true</code>).
     */
    @mcField(name="udp-server", optional=true)
    public Boolean              udpServer;
    /**
     * Enables UDP connections between local processes. (default: false)
     */
    @mcField(name="localhost-udp")
    public Boolean              localhostUDP;
    /**
     * Timeout for routes in seconds. (default: 75)
     */
    @mcField(name="route-timeout", optional=true)
    public Integer              routeTimeout;
    /**
     * Timeout for connections in seconds. (default: 10)
     */
    @mcField(name="connection-timeout", optional=true)
    public Integer              connectionTimeout;
    /**
     * Do not close idle TCP connections (default: <code>false</code>).
     */
    @mcField(name="keep-open", optional=true)
    public Boolean              keepOpen;
    /**
     * Starts a TCP server for each network interface separately
     * (default: <code>true</code>).
     *
     * <p>If this option is set <code>false</code>, then this service will bind server sockets
     * without specifying IP addresses. If this option is set <code>true</code>, then this
     * service will perform separate bind operations for each IPv4 network interface.</p>
     *
     * <p>If a socket bind operation is performed without specifying an address,
     * then the bind affects all IPv4 and IPv6 network interfaces.
     * Now, it might occur that an IPv4 port is already allocated, but the corresponding
     * IPv6 port is available. The operating system will return success on the bind
     * operation, but the resulting socket is useless for IPv4.</p>
     */
    @mcField(name="per-interface-server", optional=true)
    public Boolean              perInterfaceServer;
    /**
     * Configuration for automatic peer discovery.
     */
    @mcField(optional=true)
    public OptDiscovery         discovery;
    /**
     * A list of interfaces to send broadcast discovery messages on. (default: none)
     */
    public OptBroadcast         broadcast;
    /**
     * Configuration of IP Multicast discovery.
     */
    public OptMulticast         multicast;
    /**
     * A list of hosts to which connections should be opened. (default: none)
     */
    public TypedArray           hosts;
  }

  /**
   * Initializes a new <code>IPTransportService</code>.
   */
  public IPTransportService()
  {
  }

  /**
   * Sets configuration options for this service.
   */
  @Override
  public void setServiceConfig(Object cfg)
  {
    if (conf!=null)
      throw new IllegalStateException("reconfiguration not supported");
    conf=(Options)cfg;
  }

  /**
   * Returns the configuration options for this service.
   */
  @Override
  public Object getServiceConfig()
  {
    return conf;
  }

  /**
   * Initializes the service.
   */
  @Override
  public synchronized void init()
  {
    setState(STATE_INITIALIZING);
    LOG.fine("starting; nodeId: "+Mundo.getNodeId().shortString());
    
    // Set defaults
    if (conf == null)
      conf = new Options();
    if (conf.tcpServer == null)
      conf.tcpServer = new Boolean(true);
    if (conf.udpServer == null)
      conf.udpServer = new Boolean(false);
    if (conf.keepOpen==null)
#ifdef CFG_ANDROID
      conf.keepOpen = new Boolean(true);
#else
      conf.keepOpen = new Boolean(false);
#endif
    if (conf.protocol == null)
      conf.protocol = "bin";
    if (conf.perInterfaceServer == null)
    {
      conf.perInterfaceServer = new Boolean(true);
/*
      if ("Windows XP".equals(System.getProperty("os.name")))
        conf.perInterfaceServer=new Boolean(true);
      else
        conf.perInterfaceServer=new Boolean(false);
*/
    }

    if (conf.primaryPort == null)
      conf.primaryPort = new Integer(4242);
    if (conf.routeTimeout == null)
      conf.routeTimeout = new Integer(75);
    if (conf.connectionTimeout == null)
#ifdef CFG_ANDROID
      conf.connectionTimeout = new Integer(30);
#else
      conf.connectionTimeout = new Integer(10);
#endif
    if (conf.localhostUDP == null)
      conf.localhostUDP = new Boolean(false);

    if (conf.discovery == null)
      conf.discovery = new OptDiscovery();
    if (conf.discovery.connectToPrimary == null)
      conf.discovery.connectToPrimary = new Boolean(true);
    if (conf.discovery.sendNeighbors == null)
      conf.discovery.sendNeighbors = new Boolean(true);

    if (conf.broadcast == null)
      conf.broadcast = new OptBroadcast();
    if (conf.broadcast.send == null)
      conf.broadcast.send = new Boolean(false);
    if (conf.broadcast.answer == null)
      conf.broadcast.answer = conf.broadcast.send;
    if (conf.broadcast.interval == null)
      conf.broadcast.interval = new Integer(30);
      
    if (conf.multicast == null)
      conf.multicast = new OptMulticast();
    if (conf.multicast.send == null)
      conf.multicast.send = new Boolean(false);
    if (conf.multicast.answer == null)
      conf.multicast.answer = conf.multicast.send;
    if (conf.multicast.interval == null)
      conf.multicast.interval = new Integer(30);
    if (conf.multicast.group == null)
      conf.multicast.group = "239.255.255.42";
    if (conf.multicast.port == null)
      conf.multicast.port = new Integer(4241);
    if (conf.multicast.ttl == null)
      conf.multicast.ttl = new Integer(0);

    primaryPort = conf.primaryPort.intValue();
    
    // Protocol configuration
    if (serializers==null)
    {
#ifdef CFG_XML
      if (conf.protocol.equals("xml"))
        serializers = new XMLSerializationHandler();
      else
#endif
        serializers = new BinSerializationHandler();
    }

#ifdef CFG_CHECKED_BUILD
    log.config("primary-port: " + primaryPort);
#endif

    // Enumerate network interfaces
    interfaces = IPNetInterface.getInterfaces(conf.broadcast.nets);

    // Start UDP server
    if (conf.udpServer.booleanValue())
    {
      try
      {
        udpServerThread=new UDPServerThread();
        udpServerThread.start();
      }
      catch(Exception x)
      {
        LOG.severe("UDPServerThread failed: "+x);
        udpServerThread=null;
      }
    }

    // Give the user hints about what discovery will do and what not
#ifdef CFG_CHECKED_BUILD
    int bcastIfs = 0;
    if (interfaces!=null)
    {
      Iterator niter = interfaces.iterator();
      while (niter.hasNext())
      {
        IPNetInterface ni=(IPNetInterface)niter.next();
        if (ni.bcastAddr!=null)
          bcastIfs++;
      }
    }
    if (conf.broadcast.send.booleanValue())
    {
      discoveryLog.config("broadcast discovery is enabled for "+bcastIfs+" subnets");
      if (!conf.broadcast.answer.booleanValue())
        discoveryLog.warning("this node will only send, but not receive broadcasts!");
    }
    else
    {
      if (conf.broadcast.answer.booleanValue())
        discoveryLog.warning("this node will only receive, but not send broadcasts!");
      else
        discoveryLog.config("broadcast discovery is disabled");
      if (!conf.discovery.connectToPrimary.booleanValue())
      {
        discoveryLog.warning("no broadcast addresses configured and connectToPrimary is disabled;");
        discoveryLog.warning("most probably this node will not connect to anything!");
      }
    }
    if (conf.multicast.send || conf.multicast.answer)
    {
      discoveryLog.config("multicast discovery is enabled");
      discoveryLog.config("multicast group: "+conf.multicast.group+" port: "+conf.multicast.port);
      discoveryLog.config("multicast time-to-live: "+conf.multicast.ttl);
      discoveryLog.config("send multicast discovery messages: "+(conf.multicast.send.booleanValue() ? "yes" : "no"));
      discoveryLog.config("answer multicast discovery messages: "+(conf.multicast.answer.booleanValue() ? "yes" : "no"));
    }
    else
    {
      discoveryLog.config("multicast discovery is disabled");
    }
#endif

    // Open broadcast socket and start DiscoveryThread.
    try
    {
#ifdef CFG_J2ME
      // setReuseAddress cannot be used on J2ME. This prevents multiple
      // processes from running on the same device.
      // FIXME: Check if a MulticastSocket solves this issue... That doesn't
      //        work on MacOS, so my guess is no.
      bcastSocket = new DatagramSocket(primaryPort);
#else
      // Requires Java 1.4 API
      bcastSocket = new DatagramSocket(null);
//      bcastSocket.setReuseAddress(true);
      NetExt.setReusePort(bcastSocket, true);
      bcastSocket.bind(new InetSocketAddress(primaryPort));
#endif
      if (conf.broadcast.answer.booleanValue())
      {
        discoveryThread = new DiscoveryThread(bcastSocket);
        discoveryThread.start();
      }
    }
    catch(Exception x)
    {
    }

    // Open multicast socket and start MulticastDiscoveryThread.
    try
    {
      if (conf.multicast.send || conf.multicast.answer)
      {
        conf.multicast.groupAddr = InetAddress.getByName(conf.multicast.group);
        mcastSocket = new MulticastSocket(conf.multicast.port.intValue());
        mcastSocket.setTimeToLive(conf.multicast.ttl.intValue());
        mcastSocket.joinGroup(conf.multicast.groupAddr);
        
        if (conf.multicast.answer.booleanValue())
        {
          mcastDiscoveryThread = new DiscoveryThread(mcastSocket);
          mcastDiscoveryThread.start();
        }
      }
    }
    catch(Exception x)
    {
      log.exception(x);
    }
    
    try
    {
      setState(STATE_INITIALIZED);

      if (conf.tcpServer.booleanValue())
      {
        tcpServerThread = startServer(0);
        priTcpServerThread = startServer(primaryPort);
      }

      if (conf.discovery.connectToPrimary.booleanValue() &&
          open(new InetSocketAddress("127.0.0.1", primaryPort)))
      {
        LOG.fine("connect to 127.0.0.1:"+primaryPort+" succeeded");
      }
      
      bcastDiscoverMsg();
      mcastDiscoverMsg();

      // Create thread for performing background tasks
      workerThread = new WorkerThread();
      workerThread.start();
      return;
    }
    catch(Exception x)
    {
      log.exception(x);
    }
    setState(STATE_ERROR);
  }
  
  private TCPServerThread startServer(int port)
  {
    try
    {
      if (!conf.perInterfaceServer.booleanValue())
      {
        TCPServerThread st = new TCPServerThread(this, null, port, false);
        if (!st.open())
          return null;
        serverThreads.add(st);
        st.start();
        return st;
      }
      InetAddress loopbackAddr = InetAddress.getByName("127.0.0.1");
      TCPServerThread st = new TCPServerThread(this, loopbackAddr, port, false);
      if (!st.open())
        return null;
      port = st.getLocalPort();
      serverThreads.add(st);
      st.start();

      if (interfaces!=null)
      {
        Iterator niter = interfaces.iterator();
        while (niter.hasNext())
        {
          IPNetInterface ni = (IPNetInterface)niter.next();
          InetAddress addr = InetAddress.getByAddress(ni.addr);
          if (!loopbackAddr.equals(addr))
          {
            TCPServerThread st2 = new TCPServerThread(this, addr, port, false);
            if (st2.open())
            {
              serverThreads.add(st2);
              st2.start();
            }
          }
        }
      }
      return st;
    }
    catch(Exception x)
    {
      log.exception(x);
    }
    return null;
  }
  
  public void shutdown()
  {
#ifdef TRACE_MODULE
    trace.start();
#endif    
    setState(STATE_SHUTDOWN);

    TRACE("Terminate discoveryThread");
    DatagramSocket bsock=bcastSocket;
    bcastSocket=null;
    if (bsock!=null)
    {
      try
      {
        bsock.close();
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
    if (discoveryThread!=null)
      discoveryThread.interrupt();

    TRACE("Terminate mcastDiscoveryThread");
    MulticastSocket msock = mcastSocket;
    mcastSocket = null;
    if (msock!=null)
    {
      try
      {
        msock.leaveGroup(conf.multicast.groupAddr);
        msock.close();
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
    if (mcastDiscoveryThread!=null)
      mcastDiscoveryThread.interrupt();

    TRACE("Terminate TCP server threads");
    for (Iterator i=serverThreads.iterator(); i.hasNext();)
      ((TCPServerThread)i.next()).close();

    TRACE("Terminate udpServerThread");
    if (udpServerThread!=null)
      udpServerThread.shutdown();

    // Close all connections
    TRACE("routesSem.acquire");
    routesSem.acquire();
    try
    {
      for (Iterator i=routes.iterator(); i.hasNext();)
      {
        IPLink route=(IPLink)i.next();
        try
        {
          TRACE("lock route for disconnect");
          route.sem.acquire();
          if (route.iptc!=null)
            route.iptc.disconnect();
        }
        finally
        {
          route.sem.release();
        }
      }
      for (Iterator i=routes.iterator(); i.hasNext();)
      {
        IPLink route=(IPLink)i.next();
        try
        {
          TRACE("lock route for disconnectWait");
          route.sem.acquire();
          if (route.iptc!=null)
            route.iptc.disconnectWait();
        }
        finally
        {
          route.sem.release();
        }
      }
    }
    finally
    {
      routesSem.release();
    }

    TRACE("Terminate worker thread");
    workerThread.shutdown();
    
    for (Iterator i=serverThreads.iterator(); i.hasNext();)
      waitThread((Thread)i.next(), "tcpServerThread");
    tcpServerThread = null;
    priTcpServerThread = null;
    waitThread(workerThread, "workerThread");
    workerThread = null;
    waitThread(udpServerThread, "udpServerThread");
    udpServerThread = null;

    TRACE("Wait for close threads");
    try
    {
      int i=10;
      while (TCPTransportConnection.CloseThread.getThreadCount()>0)
      {
        if (i--<1)
        {
          log.warning("not all close threads have terminated");
          break;
        }
        log.finest("close threads are still active - waiting");
        Thread.sleep(100);
      }
    }
    catch(Exception x)
    {
      log.exception(x);
    }
        
    setState(STATE_DOWN);
    LOG.fine("shutdown complete");
#ifdef TRACE_MODULE
    trace.stop();
#endif    
  }
  private void waitThread(Thread t, String name)
  {
    if (t==null)
      return;
    try
    {
      t.join(JOIN_TIMEOUT);
    }
    catch(InterruptedException x)
    {
      LOG.exception(x);
    }
    if (t.isAlive())
    {
      LOG.severe("thread '"+name+"' did not shut down in a timely fashion");
      t.interrupt();
      try
      {
        t.join(JOIN_TIMEOUT);
      }
      catch(InterruptedException x)
      {
        LOG.exception(x);
      }
      if (t.isAlive())
      {
        LOG.severe("thread '"+name+"' could not be terminated");
      }
    }
  }
  public static int getPrimaryPort()
  {
    return primaryPort;
  }
  public int getLocalPort()
  {
    if (priTcpServerThread!=null)
      return priTcpServerThread.getLocalPort();
    if (tcpServerThread!=null)
      return tcpServerThread.getLocalPort();
    return 0;
  }
/*
  boolean isLocalPort(int port)
  {
    if (port<1)
      return false;
    return port==localPort || port==localPort2;
  }
*/  
  boolean isLocalAddress(InetAddress addr)
  {
    if (interfaces==null)
      return false;
    byte[] a = addr.getAddress();
    Iterator niter = interfaces.iterator();
    while (niter.hasNext())
    {
      IPNetInterface ni = (IPNetInterface)niter.next();
      if (Arrays.equals(ni.addr, a))
        return true;
    }
    return false;
  }
/*
  private InetAddress[] getLocalAddresses()
  {
    x.printStackTrace();
    return null;
    addrs=new InetAddress[1];
    try
    {
      addrs[0]=InetAddress.getLocalHost();
    }
    catch(Exception x2)
    {
      x2.printStackTrace();
      addrs=null;
    }
    return addrs;
  }
*/
  /**
   * Sends UDP broadcast discovery messages.
   * The <code>NodeAdd</code> message holds the node identifier
   * of this node and the port number on which our server thread is listening
   * for incoming data connections. Receivers can then open a TCP data connection
   * by using the packet source address and the port number provided by the
   * <code>NodeAdd</code> message.
   */
  private void bcastDiscoverMsg()
  {
    if (interfaces==null || !conf.broadcast.send.booleanValue())
      return;
    TypedMap map = null;
    Iterator iter = interfaces.iterator();
    while (iter.hasNext())
    {
      IPNetInterface ni = (IPNetInterface)iter.next();
      if (ni.addr!=null && ni.bcastAddr!=null)
      {
        if (map==null)
        {
          map = new TypedMap();
          initDiscoverMsg(map);
        }
        sendDiscoverMsg(ni.addr, ni.bcastAddr, map);
      }
    }
  }
  /**
   * Sends UDP multicast discovery messages.
   */
  private void mcastDiscoverMsg()
  {
    if (mcastSocket==null || !conf.multicast.send.booleanValue())
      return;
    TypedMap map = new TypedMap();
    initDiscoverMsg(map);
    multicastDiscoverMsg(map);
  }
  private void sendDiscoverMsg(byte[] a, byte[] ba, TypedMap map)
  {
    try
    {
      map.put("ipaddr", IPNetInterface.bytes2ipstr(a));
      Message msg=new Message("ipts", "passive", map);
      DatagramPacket dgram=message2datagram(msg);
#ifdef CFG_J2ME
      InetAddress bcastAddr=InetAddress.getByName(IPNetInterface.bytes2ipstr(a));
#else
      InetAddress bcastAddr=InetAddress.getByAddress(ba);
#endif      
      dgram.setAddress(bcastAddr);
      dgram.setPort(primaryPort);
      if (bcastSocket!=null)
      {
#ifdef CFG_CHECKED_BUILD
        discoveryLog.fine("UDP NodeAdd > "+bcastAddr.toString());
#endif
        bcastSocket.send(dgram);
      }
    }
    catch(Exception x)
    {
      LOG.exception(x);
    }
  }
  private void initDiscoverMsg(TypedMap map)
  {
    map.putInt("version", CURRENT_PROTOCOL_VERSION);
    map.put("request", "NodeAdd");
    map.put("vpId", Mundo.getNodeId());
    map.put("name", Mundo.getNodeName());
    if (conf.discovery.attributes != null)
      map.put("attributes", conf.discovery.attributes);
    if (conf.discovery.requiredAttribute != null)
      map.put("require-attribute", conf.discovery.requiredAttribute);
    map.putInt("port", getLocalPort());
    if (!conf.tcpServer.booleanValue())
      map.putBoolean("tcp-server", false);
    int port = getUDPPort();
    if (port>0)
      map.putInt("udp-port", port);
//    LOG.finest("initDiscoverMsg: "+map.toString());
  }
#ifndef CFG_J2ME
  private boolean sendDiscoverMsgTo(InetAddress daddr, TypedMap map)
  {
    byte[] d=daddr.getAddress();
    Enumeration ifEnum=null;
    try
    {
      ifEnum=NetworkInterface.getNetworkInterfaces();
    }
    catch(Exception x)
    {
      LOG.exception(x);
      return false;
    }
    if (ifEnum!=null)
    {
      while (ifEnum.hasMoreElements())
      {
        NetworkInterface iface=(NetworkInterface)ifEnum.nextElement();
        Enumeration addrEnum=iface.getInetAddresses();
        while (addrEnum.hasMoreElements())
        {
          InetAddress addr=(InetAddress)addrEnum.nextElement();
          if (addr instanceof Inet4Address)
          {
            byte[] s=addr.getAddress();
            if (s[0]==d[0] && s[1]==d[1] && s[2]==d[2])
            {
              map.put("ipaddr", addr.getHostAddress());
              Message msg=new Message("ipts", "passive", map);
              try
              {
                DatagramPacket dgram=message2datagram(msg);
                dgram.setAddress(daddr);
                dgram.setPort(primaryPort);
                if (bcastSocket!=null)
                {
#ifdef CFG_CHECKED_BUILD
                  discoveryLog.fine("UDP NodeAdd > "+daddr.toString());
#endif
                  bcastSocket.send(dgram);
                }
              }
              catch(IOException x)
              {
                LOG.exception(x);
              }
            }
          }
        }
      }
    }
    return true;
  }
#endif
  private void multicastDiscoverMsg(TypedMap map)
  {
    // FIXME: This solves the Mac OS local discovery problems, but not more.
    // It will be a real problem to figure out the correct IP address here...
//    map.put("ipaddr", "127.0.0.1");
    Message msg = new Message("ipts", "passive", map);
    try
    {
      DatagramPacket dgram = message2datagram(msg);
      dgram.setAddress(conf.multicast.groupAddr);
      dgram.setPort(conf.multicast.port.intValue());
#ifdef CFG_CHECKED_BUILD
      discoveryLog.fine("UDP multicast NodeAdd > "+conf.multicast.groupAddr+":"+conf.multicast.port);
#endif
      mcastSocket.send(dgram);
    }
    catch(IOException x)
    {
      LOG.exception(x);
    }
  }
#ifdef CFG_J2ME
  private static int b2i(byte b)
  {
    if (b<0)
      return 0x100+(int)b;
    return (int)b;
  }
#endif

  void iptsControlPacket(IIPTransportConnection conn,
                         InetSocketAddress senderAddr,
                         Message msg) throws Exception
  {
    if (getState() == STATE_DOWN)
    {
      log.warning("ignoring control packet after shutdown");
      return;
    }
//    try
//    {
      serializers.deserialize(msg);

      TypedMap doc=msg.getMap("ipts", "passive");
      if (doc==null)
        throw new IllegalArgumentException("chunk ipts:passive required");
//      System.out.println(msg.getRequest()+": "+doc);
      
      // Check protocol version
      int protocolVersion=doc.getInt("version", 0);
      if (protocolVersion<REQUIRED_PROTOCOL_VERSION)
      {
        LOG.fine(conn.getRemoteAddress().toString()+" speaks obsolete protocol version "+protocolVersion+" - packet dropped");
        return;
      }
      
      String request=doc.getString("request");
      if (request.equals("NodeAdd"))
      {
        LOG.fine("NodeAdd < "+doc.getGUID("vpId").shortString());
        if (Mundo.getNodeId().equals(doc.getGUID("vpId")))
        {
          LOG.fine("received NodeAdd from self!");
          return;
//        throw new IllegalStateException("received NodeAdd from self");
        }
        InetAddress addr;
        try
        {
          // If the message contains an IP address, then connect to this
          // address. NodeAdd messages sent by UDP discovery contain IP
          // addresses, because the sending process explicitly addresses
          // single network interfaces and therefore knows the originating
          // IP address. senderAddr is not used here, because it is often
          // invalid in combination with UDP broadcasts.

          addr = InetAddress.getByName(doc.getString("ipaddr"));
        }
        catch(Exception x)
        {
          // If the message does not provide an IP address, then use the
          // sender address obtained from the local networking API.
          // NodeAdd messages sent over TCP do not contain IP addresses,
          // because the sender usually lets the network stack decide
          // which interface to take. senderAddr is working reliable
          // in combination with TCP, but not UDP.
        
          addr = senderAddr.getAddress();
        }

        conn.init(doc.getGUID("vpId"), addr, doc.getInt("port", 0), doc);
        IPLink link = (IPLink)conn.getLink();
        if (link!=null)
        {
          link.remoteId = doc.getGUID("vpId");
          link.remoteName = doc.getString("name", null);
          link.set(senderAddr, new InetSocketAddress(addr, doc.getInt("port", 0)), IPLink.PROTO_TCP);
        }
        
        doc = new TypedMap();
        doc.put("request", "NodeAddReply");
        doc.putInt("version", CURRENT_PROTOCOL_VERSION);
        if (conf.tcpServer.booleanValue())
          doc.putInt("port", getLocalPort());
        doc.put("vpId", Mundo.getNodeId());
        doc.put("name", Mundo.getNodeName());
        doc.put("extAddr", senderAddr.getAddress().getHostAddress());
        doc.putInt("extPort", senderAddr.getPort());
        if (conn instanceof TCPTransportConnection)
        {
          InetAddress a = ((TCPTransportConnection)conn).getLocalAddress();
          if (a!=null)
            doc.put("intAddr", a.getHostAddress());
        }
        conn.connect();
        msg = new Message("ipts", "passive", doc);
        msg.setType(mimeType);
        serialize(msg);
        conn.send(msg);
        log.fine("NodeAddReply "+Mundo.getNodeId().shortString()+" >");

        connectionOpened(conn);
      }
      else if (request.equals("NodeAddReply"))
      {
        LOG.fine("NodeAddReply < "+doc.getGUID("vpId").shortString());
        if (Mundo.getNodeId().equals(doc.getGUID("vpId")))
          throw new IllegalStateException("received NodeAddReply from self");
        conn.init(doc.getGUID("vpId"), senderAddr.getAddress(), doc.getInt("port", 0), doc);
        IPLink link = (IPLink)conn.getLink();
        if (link!=null)
        {
          link.remoteId = doc.getGUID("vpId");
          link.remoteName = doc.getString("name", null);
          InetSocketAddress addr = null;
          try
          {
            addr = new InetSocketAddress(
                InetAddress.getByName(doc.getString("intAddr")),
                doc.getInt("port", 0));
          }
          catch(Exception x) {}
          link.set(senderAddr, addr, IPLink.PROTO_TCP);
          String s = doc.getString("extAddr", null);
          if (s!=null)
            link.setLocalExtAddress(new InetSocketAddress(s, doc.getInt("extPort", 0)));
        }
        connectionOpened(conn);
      }
      else if (request.equals("Neighbors"))
      {
        LOG.fine("rcvd Neighbors");
        try
        {
          Iterator iter=((TypedArray)doc.get("neighbors")).iterator();
          while (iter.hasNext())
          {
            TypedMap map=(TypedMap)iter.next();
            IPLink route;
            routesSem.acquire();
            try
            {
              route=findRoute(InetAddress.getByName(map.getString("ipaddr")),
                              map.getInt("port", 0));
            }
            finally
            {
              routesSem.release();
            }
            if (route!=null)
            {
              int t=map.getInt("timeout", 0);
              if (t>route.timeout)
                route.timeout=t;
            }
            else
              openAsync(map);
          }
        }
        catch(IllegalStateException x)
        {
          // connect fails if the node is shutting down
          return;
        }
        catch(NoSuchElementException x)
        {
          LOG.severe("malformed Neighbors message");
        }
      }
      else
      {
        LOG.warning("received unknown control packet: "+doc.toString());
      }
//    }
//    catch(IllegalStateException x)
//    {
      // This usually happens when the connection is closed concurrently
//    }
//    catch(Exception x)
//    {
//      LOG.exception(x);
//      System.out.println(msg);
//    }
  }

  /**
   * Acquires the lock for the routes table and adds the specified route.
   */
  void addLink(TransportLink link)
  {
    routesSem.acquire();
    try
    {
      routes.add((IPLink)link);
    }
    finally
    {
      routesSem.release();
    }
  }

  void connectionCreated(IIPTransportConnection conn)
  {
    if (getState()<STATE_INITIALIZED)
      throw new IllegalStateException("service state="+getState());
    if (getState()>=STATE_SHUTDOWN)
    {
      conn.disconnect();
//      System.out.println("immediately disconnected new connection created during shutdown");
    }
    else
    {
//      Log.println("I", "ipts.conn", "connect > "+conn.getRemoteAddress()+":"+conn.getRemotePort());
//      connections.add(conn);
    }
  }

  synchronized void connectionOpened(IIPTransportConnection conn)
  {
    LOG.info("connection + "+conn.getLink());
    // Check if this is a duplicate route
    IPLink route=(IPLink)conn.getLink();
    if (route==null)
    {
      LOG.severe("route==null");
      return;
    }

    try
    {
      route.emitSem.acquire();
      try
      {
        route.sem.acquire();
        
        // Reject loopback routes
        if (route.remoteId.equals(Mundo.getNodeId()))
        {
          LOG.fine("closing loopback route: "+route);
          route.iptc.disconnect();
          route.timeout=1;
          return;
        }
  
        // Reset timeout counter for route
        route.timeout = conf.routeTimeout.intValue();
  
        // Set timeout for connection
        if (route.iptc instanceof TCPTransportConnection)
        {
          TCPTransportConnection tcptc=(TCPTransportConnection)route.iptc;
          if (route.isPrimary())
            tcptc.setTimeoutReset(TransportLink.TIMEOUT_INFINITE);
          else
            tcptc.setTimeoutReset(conf.connectionTimeout.intValue());
        }
      }
      finally
      {
        route.sem.release();
      }
  
      if (!route.rsNotified)
      {
        route.rsNotified=true;
        emit.linkAdded(route);
      }
      emit.connectionOpened(route);
    }
    finally
    {
      route.emitSem.release();
    }

    // Check if the new connection is a connection to the local primary port
    if (!primaryConnectionOpen)
    {
      byte[] a=conn.getRemoteAddress().getAddress();
      if (a[0]==127 && a[1]==0 && a[2]==0 && conn.getRemotePort()==primaryPort)
        primaryConnectionOpen=true;
    }

    // Tell the new node about neighbours already known to us
    routesSem.acquire();
    try
    {
      sendNeighbors(route);
    }
    finally
    {
      routesSem.release();
    }
  }

  private void sendNeighbors(IPLink receiver)
  {
    if (!conf.discovery.sendNeighbors.booleanValue())
      return;
	routesSem.assertAcquired();
    TypedArray neighbors=new TypedArray();
    for (Iterator iter=routes.iterator(); iter.hasNext();)
    {
      IPLink route=(IPLink)iter.next();
      if (route==receiver)
        continue;
      try
      {
        route.sem.acquire();
        
        // skip connection if handshake is not finished
        if (route.remoteId==null)
          continue;
        // filter out connections that would loop back to the new node
        if (route.remoteId.equals(receiver.remoteId))
          continue;
        // filter out local connections if the new node is not on the same host as well
        if (route.isLoopback() && !receiver.isLoopback())
          continue;

        InetSocketAddress a = route.getPeerIntAddress();
		if (a==null)
		  a = route.getPeerExtAddress();
		if (a==null)
		  continue;

        TypedMap entry = new TypedMap();
        entry.put("vpId", route.remoteId);
        entry.put("ipaddr", a.getAddress().getHostAddress());
        entry.putInt("port", a.getPort());
        entry.putInt("timeout", route.timeout);
        neighbors.add(entry);
      }
      finally
      {
        route.sem.release();
      }
    }
    if (neighbors.size()>0)
    {
      TypedMap map = new TypedMap();
      map.putInt("version", CURRENT_PROTOCOL_VERSION);
      map.put("request", "Neighbors");
      map.put("neighbors", neighbors);
      IIPTransportConnection iptc = receiver.iptc;
      if (iptc!=null)
      {
        Message msg = new Message("ipts", "passive", map);
        try
        {
          msg.setType(mimeType);
          serialize(msg);
          iptc.send(msg);
        }
        catch(Exception x)
        {
          LOG.exception(x);
        }
      }
    }
  }

  /**
   * Sends a neighbor message to each node on the local host.
   */
  private void sendNeighborsLocal()
  {
    if (!conf.discovery.sendNeighbors.booleanValue())
      return;
    routesSem.acquire();
    try
    {
      for (Iterator iter=routes.iterator(); iter.hasNext();)
      {
        IPLink route=(IPLink)iter.next();
        try
        {
          route.sem.acquire();
          if (!route.isLoopback() || route.iptc==null)
            continue;
          try
          {
            sendNeighbors(route);
          }
          catch(Exception x)
          {
            LOG.exception(x);
          }
        }
        finally
        {
          route.sem.release();
        }
      }
    }
    finally
    {
      routesSem.release();
    }
  }

  /**
   * Called by transport connections to signal a connect operation has failed.
   */
  void connectionOpenFailed(IPLink route)
  {
    // Discard the route
    routesSem.acquire();
    try
    {
      routes.remove(route);
    }
    finally
    {
      routesSem.release();
    }
    routeRemoved(route);
  }

  private void routeRemoved(IPLink route)
  {
    route.emitSem.acquire();
    if (route.rsNotified)
    {
      route.rsNotified=false;
      try
      {
        emit.linkRemoved(route);
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
    route.emitSem.release();
  }

  /**
   * Starts a second server thread on the PRIMARY_PORT, if it became free.
   * Usually the disconnection of a connection to localhost:PRIMARY_PORT
   * indicates that the node which held the PRIMARY_PORT has shut down.
   */
  void connectionClosed(IIPTransportConnection conn)
  {
    LOG.info("connection - "+conn.getLink());
    IPLink route=(IPLink)conn.getLink();
    if (route==null)
      return;
    route.iptc=null;

    // Check if we have lost connection to the local primary port
    if (primaryConnectionOpen)
    {
      byte[] a=conn.getRemoteAddress().getAddress();
      if (a[0]==127 && a[1]==0 && a[2]==0 && conn.getRemotePort()==primaryPort)
        primaryConnectionOpen=false;
    }
  }

  /**
   * Connects to the specified peer. The method asynchronously starts a connect
   * operation to the specified peer. Always returns <code>true</code>.
   *
   * @param l  the transport link to open.
   * @return  <code>true</code>: Indicates that the operation was successfully
   *          started; or if a connection to the specified address and port is
   *          already open; or a connect operation is pending.<br/>
   * @throws IllegalStateException  if the service is currently shutting down.
   */
  public boolean openAsync(TransportLink l)
  {
    return openAsync(l, false);
  }
  public boolean openAsync(TransportLink l, boolean keepOpen)
  {
    if (getState()>=STATE_SHUTDOWN)
      throw new IllegalStateException("service is shutting down");
    IPLink route = (IPLink)l;
    try
    {
      route.sem.acquire();
      // Abort if the connection is open or a connect is already in progress
      if (route.iptc!=null)
      {
        LOG.fine("connect is already in progress");
        return true;
      }
      else
        createConnection(route, keepOpen || conf.keepOpen.booleanValue());
    }
    finally
    {
      route.sem.release();
    }
    new ConnectThread(route).start();
    return true;
  }
  /**
   * Creates either a UDP or a TCP connection object for the specified route.
   */
  private void createConnection(IPLink route, boolean keepOpen)
  {
    if (route.getProto() == route.PROTO_UDP)
    {
      UDPTransportConnection udptc = new UDPTransportConnection(route);
      route.iptc = udptc;
      String connKey = route.getPeerExtAddress().toString();
      LOG.finer("udpHash.put " + connKey);
      udpHash.put(connKey, udptc);
    }
    else
    {
      TCPTransportConnection tcptc = new TCPTransportConnection(route);
      tcptc.setKeepOpen(keepOpen);
      route.iptc = tcptc;
    }
    LOG.fine("created connection "+route);
  }
  /**
   * Connects to the specified peer. The method asynchronously starts a connect
   * operation to the specified peer.
   *
   * @param addr  the external IP address and port of the remote peer.
   * @return  <code>true</code>: Indicates that the operation was successfully
   *          started; or if a connection to the specified address and port is
   *          already open; or a connect operation is pending.<br/>
   * @throws IllegalStateException  if the service is currently shutting down.
   */
  public boolean openAsync(InetSocketAddress addr, boolean keepOpen)
  {
    if (getState()>=STATE_SHUTDOWN)
      throw new IllegalStateException("service is shutting down");
    IPLink link;
    routesSem.acquire();
    try
    {
      link = findRoute(addr);
      if (link==null)
        routes.add(link = new IPLink(this, addr, IPLink.PROTO_TCP));
    }
    finally
    {
      routesSem.release();
    }
    return openAsync(link, keepOpen);
  }
  /**
   * Connects to the specified peer. The method asynchronously starts a connect
   * operation to the specified peer. The map parameter is usually provided in
   * neighbour messages.
   *
   * @param map  a map containing <code>string ipaddr</code> and <code>int port</code>.
   * @return  <code>true</code>: Indicates that the operation was successfully
   *          started; or if a connection to the specified address and port is
   *          already open; or a connect operation is pending.<br/>
   *          <code>false</code>: if a parameter is missing in the map;
   *          or if the specified host is unknown.
   *
   * @see ITransportService
   */
  public boolean openAsync(TypedMap map) /*ITransportService*/
  {
    try
    {
      return openAsync(new InetSocketAddress(
          InetAddress.getByName(map.getString("ipaddr")),
          map.getInt("port")),
          map.getBoolean("keep-open", false));
    }
    catch(UnknownHostException x)
    {
      LOG.exception(x);
      return false;
    }
    catch(NoSuchElementException x)
    {
      LOG.exception(x);
      return false;
    }
  }
  /**
   * Connects to the specified peer.
   *
   * @param tl  the transport link to open.
   * @return  <code>true</code>: Indicates that the socket could be connected
   *          successfully. However, this does not necessarily mean that the
   *          connection could be set up successfully, because this also requires
   *          a successful handshake; or if a connection to the specified
   *          address and port is already open; or a connect operation is pending.<br/>
   *          <code>false</code>: If the socket could not be opened.
   * @throws IllegalStateException  if the service is currently shutting down.
   */
  private boolean open(TransportLink tl)
  {
    LOG.finest("open > " + tl);
    if (getState()>=STATE_SHUTDOWN)
      throw new IllegalStateException("service is shutting down");
    IPLink link = (IPLink)tl;
    
    IIPTransportConnection iptc = null;
    try
    {
      link.sem.acquire();
      // Abort if the connection is open or a connect is already in progress
      if (link.iptc!=null)
      {
        if (link.iptc.getState()!=IIPTransportConnection.STATE_NULL)
          return true;
      }
      else
      {
        createConnection(link, conf.keepOpen.booleanValue());
      }
      iptc = link.iptc;
    }
    finally
    {
      link.sem.release();
    }
    LOG.info("connect > "+link);
    try
    {
      return iptc.connect();
    }
    catch(Exception x)
    {
      try
      {
        link.sem.acquire();
        link.iptc=null;
      }
      finally
      {
        link.sem.release();
      }
      LOG.exception(x);
    }
    return false;
  }
  /**
   * Connects to the specified peer.
   *
   * @param addr  the external IP address and port of the remote peer.
   * @return  <code>true</code>: Indicates that the socket could be connected
   *          successfully. However, this does not necessarily mean that the
   *          connection could be set up successfully, because this also requires
   *          a successful handshake; or if a connection to the specified
   *          address and port is already open; or a connect operation is pending.<br/>
   *          <code>false</code>: If the socket could not be opened.
   * @throws IllegalStateException  if the service is currently shutting down.
   */
  public boolean open(InetSocketAddress addr)
  {
    if (getState()>=STATE_SHUTDOWN)
      throw new IllegalStateException("service is shutting down");
    IPLink link;
    routesSem.acquire();
    try
    {
      link = findRoute(addr);
      if (link==null)
        routes.add(link = new IPLink(this, addr, IPLink.PROTO_TCP));
    }
    finally
    {
      routesSem.release();
    }
    return open(link);
  }

  /**
   *
   */
  public boolean down(Message msg) // IMessageHandler
  {
    TypedMap p = (TypedMap)msg.getMap("ts", "param");
#ifdef CFG_CHECKED_BUILD
    if (p==null)
    {
      LOG.warning("missing ts.param");
      return true;
    }
#endif
    TransportLink link = (TransportLink)p.get("link");
#ifdef CFG_CHECKED_BUILD
    if (link==null)
    {
      LOG.warning("missing link in ts.param");
      return true;
    }
#endif
    if ("openAsync".equals(p.getString("request", null)))
      return openAsync(link, false);
    return send(link, msg);
  }
  /**
   *
   */
  public boolean up(Message msg) // IMessageHandler
  {
    return false;
  }
  /**
   * Sends the specified message over the specified transport link. If the link does
   * not have an open connection, the operation fails.
   * @param l  the transport link object.
   * @param msg  the message to send.
   * @return     <code>true</code> if the message could be sent successfully;
   *             <code>false</code> otherwise.
   */
  public boolean send(TransportLink l, Message msg)
  {
    IPLink route = (IPLink)l;
    if (route.iptc==null)
      return false;
    return route.iptc.send(msg);
  }

  /**
   * Called when a routing service control packet was received.
   */
  // FIXME: Is this method called?
  void rsControlPacket(IIPTransportConnection conn,
                       InetAddress senderAddr,
                       Message msg)
  {
    TypedMap map=msg.getMap("rs", "passive");
    if (map.get("request").equals("NodeShutdown"))
    {
      GUID id=map.getGUID("vpId");
      ArrayList list=new ArrayList();
      routesSem.acquire();
      try
      {
        for (Iterator iter=routes.iterator(); iter.hasNext();)
        {
          IPLink route=(IPLink)iter.next();
          boolean b;
          try
          {
            route.sem.acquire();
            b=id.equals(route.remoteId);
          }
          finally
          {
            route.sem.release();
          }
          if (b)
          {
            iter.remove();
            list.add(route);
          }
        }
      }
      finally
      {
        routesSem.release();
      }
      for (Iterator iter=list.iterator(); iter.hasNext();)
        routeRemoved((IPLink)iter.next());
    }
  }

  /**
   * Called by transport connections when a packet was received.
   */
  void messageReceived(IIPTransportConnection conn, InetSocketAddress senderAddr, Message msg)
  {
    try
    {
      LOG.finest("passing message up");
      TypedMap tsmap = new TypedMap();
      tsmap.put("link", conn.getLink());
      msg.put("ts", "param", tsmap);
      emit.up(msg);
    }
    catch(Exception x)
    {
      LOG.exception(x);
    }
  }

  private DatagramPacket message2datagram(Message msg) throws IOException
  {
    serializers.serialize(msg);
    byte[] bytes=msg.getBlob("all").getBuffer();
    return new DatagramPacket(bytes, bytes.length);
  }

  private Message datagram2message(DatagramPacket dgram) throws IOException
  {
    Blob blob = new Blob();
    blob.write(dgram.getData(), 0, dgram.getLength());
    Message msg=new Message();
    msg.put("all", "bin", blob);
    serializers.deserialize(msg);
    return msg;
  }
  
  void serialize(Message msg) throws IOException
  {
    serializers.serialize(msg);
  }
  
  void deserialize(Message msg) throws IOException
  {
    serializers.deserialize(msg);
  }
  
  /**
   * Finds a route by the specified remoteId, address and port.
   */
  private IPLink findRoute(GUID remoteId, InetAddress addr, int port)
  {
    routesSem.assertAcquired();
    for (Iterator iter=routes.iterator(); iter.hasNext();)
    {
      IPLink link = (IPLink)iter.next();
      try
      {
        link.sem.acquire();
        if (remoteId.equals(link.remoteId) && addr.equals(link.getPeerExtAddress()))
        return link;
      }
      finally
      {
        link.sem.release();
      }
    }
    return null;
  }
  /**
   * Finds a route by the specified address and port.
   */
  private IPLink findRoute(InetAddress addr, int port)
  {
    return findRoute(new InetSocketAddress(addr, port));
  }
  /**
   * Finds a route by the specified address and port.
   */
  private IPLink findRoute(InetSocketAddress addr)
  {
    routesSem.assertAcquired();
    for (Iterator iter=routes.iterator(); iter.hasNext();)
    {
      IPLink link = (IPLink)iter.next();
      try
      {
        link.sem.acquire();
        if (addr.equals(link.getPeerExtAddress()))
          return link;
      }
      finally
      {
        link.sem.release();
      }
    }
    return null;
  }

  private static byte[] ipstr2bytes(String s)
  {
    // Do some quick checks, because Exceptions are slow
    if (s.length()<7)
      return null;
    char c=s.charAt(0);
    if (c<'0' || c>'9')
      return null;
      
    // Parse IPv4 number
    try
    {
      byte[] a=new byte[4];
      int i=s.indexOf('.');
      if (i<0)
        return null;
      String t=s.substring(0, i);
      a[0]=(byte)Integer.parseInt(t);
      s=s.substring(i+1);

      i=s.indexOf('.');
      if (i<0)
        return null;
      t=s.substring(0, i);
      a[1]=(byte)Integer.parseInt(t);
      s=s.substring(i+1);

      i=s.indexOf('.');
      if (i<0)
        return null;
      t=s.substring(0, i);
      a[2]=(byte)Integer.parseInt(t);
      s=s.substring(i+1);
      
      a[3]=(byte)Integer.parseInt(s);

      return a;
    }
    catch(NumberFormatException x)
    {
    }
    return null;
  }

  private static InetAddress getAddrByName(String s) throws UnknownHostException
  {
#ifndef CFG_J2ME
    byte[] a=ipstr2bytes(s);
    if (a!=null)
    {
      // This is a workaround. Providing an empty hostname will prevent
      // 'new Socket' from trying to perform a reverse lookup. If the target
      // IP does not have a hostname (happens frequently in ad-hoc networks),
      // 'new Socket' would block for ~10 seconds (depending on the OS).
      return InetAddress.getByAddress("", a);
    }
#endif
    // Get address by host name
    return InetAddress.getByName(s);
  }
  private static InetSocketAddress getAddrByName(String s, int p) throws UnknownHostException
  {
    return new InetSocketAddress(getAddrByName(s), p);
  }
  
  private void processHostsList()
  {
    if (conf.hosts==null)
      return;

    Iterator iter = conf.hosts.iterator();
    while (iter.hasNext())
    {
      try
      {
        OptHost h=(OptHost)iter.next();
        int port=(h.port!=null) ? h.port.intValue() : primaryPort;
        if (h.lastRetry==0)
        {
          LOG.fine("explicit connect > "+h.name+":"+port);
          openAsync(getAddrByName(h.name, port), true);
          h.lastRetry=System.currentTimeMillis();
        }
        else
        {
          int iv=0;
          if (routes.size()==0 && h.disconnectedRetryInterval!=null)
            iv=h.disconnectedRetryInterval.intValue();
          else if (h.retryInterval!=null)
            iv=h.retryInterval.intValue();
          if (iv>0 && h.lastRetry+iv*1000<System.currentTimeMillis())
          {
            LOG.fine("retry explicit connect > "+h.name+":"+port);
            openAsync(getAddrByName(h.name, port), true);
            h.lastRetry=System.currentTimeMillis();
          }
        }
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
  }

#ifdef CFG_JAVA15
  private static Method getDeclaredAccessibleMethod(Class c, String methodname, Class ... parametertypes) throws PrivilegedActionException
  {
    // iterate over the methods declared by the class itself as getMethod would
    // simply pretend that a non-public method is not declared
    for (Method m : c.getDeclaredMethods())
    {
      // found it!
      if (methodname.equals(m.getName()) && Arrays.equals(m.getParameterTypes(), parametertypes))
      {
        final Method manipulate = m;
        // Wrap actual access-setting in doPrivileged to
        // allow for private/protected field access in more cases.
        AccessController.doPrivileged(new PrivilegedExceptionAction() {
          public Object run() throws Exception {
            // make it accessible
            if(!manipulate.isAccessible()) {
              manipulate.setAccessible(true);
            }
            return null;
          }
        });
        return manipulate;
      }
    }
    throw new IllegalArgumentException("Method name " + methodname + " not found");
  }

  private static final int SO_REUSEPORT = 0x200;
#endif
  
  private static void setReusePort(DatagramSocket sock, boolean b)
  {
#ifdef CFG_JAVA15
    try
    {
      DatagramSocketImpl impl = (DatagramSocketImpl)getDeclaredAccessibleMethod(
          DatagramSocket.class, "getImpl").invoke(sock);
      // the PlainDatagramSocketImpl has some nasty pre-checking of options that
      // throws a SocketException for unknown options - ouch!
      // use the direct option setting feature - again with reflection
      // also, PlainDatagramSocketImpl is package private, so instanceof testing
      // must be done by string equality

      try
      {
        impl.setOption(SO_REUSEPORT, Boolean.valueOf(b));
        LOG.finest("SO_REUSEPORT set with Java method");
        return;
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }

      if ("java.net.PlainDatagramSocketImpl".equals(impl.getClass().getName()))
      {
        try
        {
          getDeclaredAccessibleMethod(impl.getClass(), "socketSetOption", Integer.TYPE,
              Object.class).invoke(impl, SO_REUSEPORT, Boolean.valueOf(b));
          LOG.finest("SO_REUSEPORT set with native method");
        }
        catch(InvocationTargetException x)
        {
          LOG.exception(x);
        }
      }
    }
    catch (Throwable t)
    {
      LOG.exception(t);
    }
#endif
  }
  
#ifdef DEBUG_MODULE
#  define LOG connectLog
#endif

  class ConnectThread extends Thread
  {
    ConnectThread(IPLink r)
    {
#ifndef CFG_CLDC
      super(Mundo.getThreadGroup(), "ipts.connect");
#endif
      route=r;
      this.forced=false;
    }
    ConnectThread(IPLink r, boolean forced)
    {
#ifndef CFG_CLDC
      super(Mundo.getThreadGroup(), "ipts.connect");
#endif
      route=r;
      this.forced=forced;
    }
    public void run()
    {
      try
      {
        if (forced)
          route.iptc.connect();
        else
          open(route);
      }
      catch(Exception x)
      {
        LOG.log(Logger.INFO, "", x);
      }
    }
    private IPLink route;
    private boolean forced;
  }

#ifdef CFG_CHECKED_BUILD
#  define LOG udpServerLog
#endif
  
  class UDPServerThread extends Thread
  {
    UDPServerThread() throws SocketException
    {
#ifndef CFG_CLDC
      super(Mundo.getThreadGroup(), "ipts.udpsrv");
#endif
      udpServerSocket=new DatagramSocket();
      LOG.fine("UDP server port "+udpServerSocket.getLocalPort());
    }
    public void run()
    {
      LOG.finer("UDPServerThread started");
      try
      {
        for(;;)
        {
          byte buf[]=new byte[65536];
          DatagramPacket dgram=new DatagramPacket(buf, 65536);
          udpServerSocket.receive(dgram);

          LOG.finest("udpsrv < "+dgram.getAddress()+":"+dgram.getPort()+", len="+dgram.getLength());
          try
          {
            String connKey = dgram.getAddress().toString()+":"+dgram.getPort();
            UDPTransportConnection conn = (UDPTransportConnection)udpHash.get(connKey);
            if (conn==null)
            {
              IPLink link = new IPLink(IPTransportService.this, new InetSocketAddress(
                  dgram.getAddress(), dgram.getPort()), IPLink.PROTO_UDP);
              createConnection(link, false);
              routesSem.acquire();
              try
              {
                routes.add(link);
              }
              finally
              {
                routesSem.release();
              }
              conn = (UDPTransportConnection)link.iptc;
              connectionCreated(conn);
            }

            byte[] a = dgram.getData();
            if (a[0] == MSGTYPE_CTRL_BIN)
            {
              Blob blob = new Blob();
              blob.write(a, 1, dgram.getLength()-1);
              Message msg = new Message();
              msg.put("all", "bin", blob);
              iptsControlPacket(conn, new InetSocketAddress(dgram.getAddress(), dgram.getPort()), msg);
            }
            else if (a[0] == MSGTYPE_DATA)
            {
              Blob blob = new Blob();
              blob.write(a, 2+a[1], dgram.getLength()-2-a[1]);
              Message msg = new Message();
              msg.put("all", "bin", blob);

              TypedMap amap = new TypedMap();
              amap.putString("mimeType", new String(a, 2, a[1]));
              msg.put("address", "passive", amap);
              
              messageReceived(conn, new InetSocketAddress(dgram.getAddress(), dgram.getPort()), msg);
            }
            else
            {
              LOG.info("unknown packet type "+a[0]);
            }
          }
          catch(Exception x)
          {
            LOG.exception(x);
          }
        }
      }
      catch(Exception x)
      {
        if (!shutdownFlag)
        {
          LOG.exception(x);
        }
      }
      udpServerSocket.close();
      udpServerSocket=null;
      LOG.finer("UDPServerThread stopped");
    }
    int getPort()
    {
      if (udpServerSocket!=null)
        return udpServerSocket.getLocalPort();
      return 0;
    }
    void shutdown()
    {
      try
      {
        shutdownFlag=true;
        udpServerSocket.close();
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
    DatagramSocket udpServerSocket;
    private boolean shutdownFlag=false;
  }

  int getUDPPort()
  {
    int port=0;
    if (udpServerThread!=null)
      port=udpServerThread.getPort();
    if (port==0 && conf.udpServer.booleanValue())
      throw new IllegalStateException("UDP server socket not initialized");
    return port;
  }
  
  void sendDatagram(DatagramPacket dgram)
  {
    try
    {
      LOG.finest("sendDatagram: length="+dgram.getLength());
      udpServerThread.udpServerSocket.send(dgram);
    }
    catch(Exception x)
    {
      LOG.fine("sendDatagram failed: "+x.toString());
    }
  }
  
#ifdef CFG_CHECKED_BUILD
#  define LOG discoveryLog
#endif

  class DiscoveryThread extends Thread
  {
    DiscoveryThread(DatagramSocket ds)
    {
#ifndef CFG_CLDC
      super(Mundo.getThreadGroup(), "ipts.discover");
#endif
      sock=ds;
    }
    public void run()
    {
      try
      {
        for(;;)
        {
          byte buf[] = new byte[BUFFER_SIZE];
          DatagramPacket dgram = new DatagramPacket(buf, BUFFER_SIZE);
          sock.receive(dgram);

          LOG.fine("UDP < "+dgram.getAddress()+":"+dgram.getPort());
          try
          {
            Message msg = datagram2message(dgram);
            TypedMap map = msg.getMap("ipts", "passive");
            if (map!=null)
            {
              packetReceived(map, msg, dgram.getAddress());
            }
            else
            {
              LOG.severe("message not understood: "+msg);
            }
          }
          catch(Exception x)
          {
            LOG.severe("UDP msg exception: "+x.toString());
          }
        }
      }
      catch(Exception x)
      {
        if (!"socket closed".equals(x.getMessage().toLowerCase()))
        {
          LOG.exception(x);
        }
      }
      LOG.finest("DiscoveryThread terminated");
    }
    private boolean checkAttributes(TypedMap map)
    {
      // Check if the remote peer meets our requirements
      if (conf.discovery.requiredAttribute != null)
      {
        String attributes=map.getString("attributes", null);
        if (attributes==null)
        {
          LOG.fine("peer has no attributes, required is "+conf.discovery.requiredAttribute);
          return false;
        }
        if (attributes.indexOf(conf.discovery.requiredAttribute)>=0)
        {
          LOG.fine("peer with attributes "+attributes+" matches required attribute");
        }
        else
        {
          LOG.fine("peer has attributes "+attributes+", but required is "+conf.discovery.requiredAttribute);
          return false;
        }
      }
      
      // Check if we meet the remote peer's requirements
      String reqd=map.getString("require-attribute", null);
      if (reqd!=null)
      {
        if (conf.discovery.attributes==null)
        {
          LOG.fine("no attributes set, but peer requires "+reqd);
          return false;
        }
        if (conf.discovery.attributes.indexOf(reqd)>=0)
        {
          LOG.fine("peer requires "+reqd+" and matches");
        }
        else
        {
          LOG.fine("peer requires "+reqd+", but set are "+conf.discovery.attributes);
          return false;
        }
      }
      return true;
    }
    /**
     * Called when a UDP packet is received.
     */
    private void packetReceived(TypedMap map, Message msg, InetAddress senderAddr)
    {
      GUID guid = map.getGUID("vpId");
      LOG.fine("UDP "+map.getString("request")+" < "+guid.shortString());
      if (guid.equals(Mundo.getNodeId()))
        return;
//      LOG.finest(map.toString());

      // Read address and port of the peer
      InetAddress addr;
      int port;
      try
      {
        String addrStr = map.getString("ipaddr", null);
        if (addrStr!=null)
          addr = getAddrByName(addrStr);
        else
          addr = senderAddr;
        port = map.getInt("port", 0);
      }
      catch(Exception x)
      {
        LOG.exception(x);
        return;
      }
      
      // Check protocol version
      int protocolVersion=map.getInt("version", 0);
      if (protocolVersion<REQUIRED_PROTOCOL_VERSION)
      {
        LOG.warning(addr.toString()+":"+port+" speaks obsolete protocol version "+protocolVersion+" - packet dropped");
        return;
      }

      if (!checkAttributes(map))
        return;
#ifndef CFG_J2ME
/*      if (!map.getBoolean("tcp-server", true))
      {
        LOG.fine("peer has no TCP server - sending UDP reply");
        TypedMap dscMap=new TypedMap();
        initDiscoverMsg(dscMap);
        sendDiscoverMsgTo(addr, dscMap);
        return;
      }
*/
#endif
      IPLink route = null;
      routesSem.acquire();
      try
      {
        int udpPort;
        if ((udpPort=map.getInt("udp-port", 0))>0)
        {
          // Abort if the route is already known
          route = findRoute(addr, udpPort);
          if (route!=null)
          {
            LOG.finer("found UDP route - timeout reset");
            // Reset timeout counter for route
            route.timeout = conf.routeTimeout.intValue();
            return;
          }
          if (conf.localhostUDP.booleanValue() || !isLocalAddress(addr))
          {
            LOG.finer("creating new UDP route");
            route = new IPLink(IPTransportService.this, new InetSocketAddress(addr, udpPort), IPLink.PROTO_UDP);
          }
          else
          {
            LOG.finer("ignoring local address: "+addr);
            return;
          }
        }
        else if (map.getBoolean("tcp-server", true))
        {
          // Abort if the route is already known
          route = findRoute(addr, port);
          if (route!=null)
          {
            if (route.remoteId.equals(guid))
            {
              LOG.finer("found TCP route - timeout reset");
              // Reset timeout counter for route
              route.timeout = conf.routeTimeout.intValue();
              return;
            }
            else
            {
              // We have found a route, but there is a different peer now
              // on the other side. Discard the old route and create a new one.
              LOG.finer("found obsolete TCP route");
              route.timeout = 0;
            }
          }
          LOG.finer("creating new TCP route");
          route = new IPLink(IPTransportService.this, new InetSocketAddress(addr, port), IPLink.PROTO_TCP);
        }
        createConnection(route, conf.keepOpen.booleanValue());
        routes.add(route);
      }
      finally
      {
        routesSem.release();
      }
      if (route==null)
      {
        LOG.fine("no route");
        return;
      }

      // Handle request      
      try
      {
        String request=map.getString("request");
        if (request.equals("NodeAdd"))
        {
          if (route.getPeerExtAddress().getPort()==0)
          {
            LOG.warning("no port number in connect");
          }
          else
          {
            route.iptc.init(map.getGUID("vpId"), addr, port, map);
            route.remoteId = map.getGUID("vpId");
            route.remoteName = map.getString("name", null);
            if (route.getProto() == route.PROTO_UDP)
              route.iptc.connect();
            else
              new ConnectThread(route, true).start();
          }
        }
        else
        {
          LOG.warning("UDP unknown control packet: "+map.toString());
        }
      }
      catch(IllegalStateException x)
      {
        // This usually happens when the connection is closed concurrently
      }
      catch(Exception x)
      {
        LOG.exception(x);
      }
    }
    private DatagramSocket sock;
  }

#ifdef CFG_CHECKED_BUILD
#  define LOG workerLog
#endif
  
  /**
   * Starts a second server thread on the PRIMARY_PORT, if it is free.
   * The PRIMARY_PORT should always be occupied by a server thread on any
   * host that runs at least one MundoCore process, because this is the
   * only way to open connections in case the UDP discovery packets are
   * not transported by the underlying network or the loopback interface.
   */
  void claimPrimaryPort()
  {
    // Abort if we are currently shutting down
    if (getState()>=STATE_SHUTDOWN)
      return;
  
    if (priTcpServerThread!=null)
    {
//      LOG.finest("primary port already owned");
      return;
    }

    if (primaryConnectionOpen)
    {
//      LOG.finest("connection to primary port already open");
      return;
    }

    priTcpServerThread = startServer(primaryPort);
    if (priTcpServerThread!=null)
    {
      LOG.finest("bind primary port succeeded");
      return;
    }

    if (!conf.discovery.connectToPrimary.booleanValue())
      return;
    InetAddress loopbackAddress = null;
    try
    {
      loopbackAddress = InetAddress.getByName("127.0.0.1");
    }
    catch(UnknownHostException x)
    {
      // This can't happen under normal circumstances.
      log.exception(x);
      return;
    }
    open(new InetSocketAddress(loopbackAddress, primaryPort));
  }

  /**
   * The worker thread performs the following background tasks:
   * - Closing time out transport connections
   * - Closing time out routes
   * - Closing transport connections rejected at connection setup
   * - Periodically sending UDP discovery packets
   * - Periodically sending neighbor messages to nodes on the same host
   */
  private class WorkerThread extends Thread
  {
    WorkerThread()
    {
#ifndef CFG_CLDC
      super(Mundo.getThreadGroup(), "ipts.worker");
#endif
      running=true;
      unclean=true;
    }
    public void shutdown()
    {
      running=false;
    }
    public void run()
    {
      try
      {
        Thread.sleep(1000);
        while (running || unclean)
        {
#ifdef TRACE_MODULE
          long startTime=System.currentTimeMillis();
          unclean=checkTimeouts();
          LOG.finest("checkTimeouts took "+(System.currentTimeMillis()-startTime)+" ms");
          startTime=System.currentTimeMillis();
          claimPrimaryPort();
          LOG.finest("claimPrimaryPort took "+(System.currentTimeMillis()-startTime)+" ms");
          startTime=System.currentTimeMillis();
          sendBroadcast();
          sendMulticast();
          LOG.finest("sendBroadcast took "+(System.currentTimeMillis()-startTime)+" ms");
          startTime=System.currentTimeMillis();
          processHostsList();
          LOG.finest("processHostsList took "+(System.currentTimeMillis()-startTime)+" ms");
#else
          unclean=checkTimeouts();
          claimPrimaryPort();
          sendBroadcast();
          sendMulticast();
          processHostsList();
#endif
          Thread.sleep(1000);
        }
      }
      catch(InterruptedException x)
      {
        // Someone forces shutdown
        LOG.severe("forced shutdown of IPTransportService.WorkerThread");
        return;
//        LOG.exception(x);
      }
      catch(IllegalStateException x)
      {
        // This exception may happen during shutdown
        if (IPTransportService.this.getState()<STATE_SHUTDOWN)
        {
          LOG.exception(x);
        }
      }
      catch(Exception x)
      {
        LOG.exception(x);
        return;
      }
      if (!unclean)
        return;
      // Wait until all connections are closed
      try
      {
        while (checkTimeouts())
          Thread.sleep(100);
      }
      catch(InterruptedException x)
      {
        // Someone forces shutdown
        LOG.severe("forced shutdown of IPTransportService.WorkerThread");
//        LOG.exception(x);
      }
    }
    /**
     * @return  true if one or more connections are open, false if all are closed
     */
    private boolean checkTimeouts()
    {
      boolean open=false;
      ArrayList delList = null;
      routesSem.acquire();
      try
      {
        IPLink route;
        for (Iterator i=routes.iterator(); i.hasNext();)
        {
          route=(IPLink)i.next();
          route.lease.set(0);
          if (route.sem.tryAcquire())
          {
            try
            {
              if (route.iptc!=null)
              {
                try
                {
                  open |= route.iptc.checkTimeout(1);
                }
                catch(Exception x)
                {
                  LOG.exception(x);
                  return true;
                }
              }
              if (route.iptc==null || route.iptc instanceof UDPTransportConnection)
              {
                route.timeout--;
                if (route.timeout<=0)
                {
                  i.remove();
                  if (delList==null)
                    delList = new ArrayList();
                  delList.add(route);
                }
              }
            }
            finally
            {
              route.sem.release();
            }
          }
        }
      }
      finally
      {
        routesSem.release();
      }
      if (delList != null)
      {
        for (Iterator iter=delList.iterator(); iter.hasNext();)
          routeRemoved((IPLink)iter.next());
      }
      return open;
    }
    private void sendBroadcast()
    {
      if (!conf.broadcast.send.booleanValue())
        return;
      if (conf.broadcast.interval.intValue() < 1)
        return;
      bcastCnt++;
      if (bcastCnt >= conf.broadcast.interval.intValue())
      {
//        cnt++;
        bcastDiscoverMsg();
        sendNeighborsLocal();
        bcastCnt=0;
      }
    }
    private void sendMulticast()
    {
      if (!conf.multicast.send.booleanValue())
        return;
      if (conf.multicast.interval.intValue() < 1)
        return;
      mcastCnt++;
      if (mcastCnt >= conf.multicast.interval.intValue())
      {
        mcastDiscoverMsg();
        mcastCnt=0;
      }
    }
    private boolean running;
    private boolean unclean;
    private int bcastCnt=0;
    private int mcastCnt=0;
//    private int cnt=0;
  }

  static final int MSGTYPE_08       = 0;
  static final int MSGTYPE_DATA     = 1;
  static final int MSGTYPE_CTRL_BIN = 2;
  static final int MSGTYPE_MAX      = 2;

  static int primaryPort;
  private DatagramSocket bcastSocket;
  private MulticastSocket mcastSocket;
  private DiscoveryThread discoveryThread;
  private DiscoveryThread mcastDiscoveryThread;
  private TCPServerThread tcpServerThread;
  private TCPServerThread priTcpServerThread;
  private UDPServerThread udpServerThread;
//  private Hashtable neighbours;
  private final String xmlns="http://mundo.org/IPTransportService/discover";
//  private Vector connections;
  private boolean primaryConnectionOpen=false;
//  private Vector connections = new Vector();
  private WorkerThread workerThread;
  Options conf;
  ISerialize serializers=null;
#ifdef CFG_JAVA15
  private ArrayList<IPNetInterface> interfaces;
  private ArrayList<IPLink> routes = new ArrayList<IPLink>();
  private HashMap<String,UDPTransportConnection> udpHash = new HashMap<String,UDPTransportConnection>();
  private HashSet<TCPServerThread> serverThreads = new HashSet<TCPServerThread>();
#else
  private ArrayList interfaces;
  private ArrayList routes = new ArrayList();
  private HashMap udpHash = new HashMap();
  private HashSet serverThreads = new HashSet();
#endif
  private Semaphore routesSem = new Semaphore(1);
  private static Logger log = Logger.getLogger("ipts");
  private static Logger workerLog = Logger.getLogger("ipts.worker");
  private static Logger discoveryLog = Logger.getLogger("ipts.dsc");
  private static Logger connectLog = Logger.getLogger("ipts.conn");
  private static Logger udpServerLog = Logger.getLogger("ipts.udpsrv");
#ifdef TRACE_MODULE
  private Tracer trace = new Tracer("ipts");
#endif

  private static final int BUFFER_SIZE = 1024;
  private static final int JOIN_TIMEOUT = 3000;

  private static final int OPEN_PRIMARY       = 1;
  private static final int OPEN_PRIMARY_REUSE = 2;
  private static final int OPEN_ANY           = 3;

#ifdef CFG_COMPAT
  static final int REQUIRED_PROTOCOL_VERSION = 820;
  static final int CURRENT_PROTOCOL_VERSION  = 830;
#else
  static final int REQUIRED_PROTOCOL_VERSION = 900;
  static final int CURRENT_PROTOCOL_VERSION  = 902;
#endif

  static final String mimeType = "message/mc-ipts";
}
