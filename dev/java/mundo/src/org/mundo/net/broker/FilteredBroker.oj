/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 * Stefan Radomski
 */

package org.mundo.net.broker;

import java.util.ArrayList;
import java.util.Iterator;

import org.mundo.filter.IActiveFilter;
import org.mundo.filter.IFilter;
import org.mundo.rt.IBCLProvider;
import org.mundo.rt.IReceiver;
import org.mundo.rt.Message;
import org.mundo.rt.MessageContext;
import org.mundo.rt.Mundo;
import org.mundo.rt.Service;
import org.mundo.rt.Signal;
import org.mundo.rt.Subscriber;
import org.mundo.rt.Publisher;
import org.mundo.rt.TypedMap;
import org.mundo.service.DoIServiceManager;
import org.mundo.service.FilteredSet;
import org.mundo.rt.DoObject;
import org.mundo.rt.Session;

/**
 * A message routing service that supports content-based Publish/Subscribe. In essence,
 * this is the same code as the ContentBroker, but it uses the new methods from IFilter.
 * @author Stefan Radomski
 */
public class FilteredBroker
       extends Service
       implements IBCLProvider.ISignal, IReceiver
{
  /**
   * Initializes a new <code>ContentRoutingService</code>.
   */
  public FilteredBroker()
  {
  }
  /**
   * Initializes this service.
   */
  public void init()
  {
    // watch new subscriptions in the local runtime
    Signal.connect("rt", IBCLProvider.ISignal.class, this);
    
    getSession().subscribe("lan", "ContentSubscription", this);
  }
  public void publisherAdded(Publisher p) /* IBCLProvider.ISignal */
  {
  }
  public void publisherRemoved(Publisher p) /* IBCLProvider.ISignal */
  {
  }
  public void subscriberAdded(Subscriber s) /* IBCLProvider.ISignal */
  {
    if (!(s.getParam() instanceof FilteredSubscription))
      return;
    FilteredSubscription cs=(FilteredSubscription)s.getParam();
    subscriptions.add(s);
  }
  public void subscriberRemoved(Subscriber s) /* IBCLProvider.ISignal */
  {
  }
  
  public void received(Message msg, MessageContext ctx)
  {
    TypedMap map=msg.getMap("main", "passive");
    if (map==null) {
      // we need to passivate the message first
      try {
        msg.passivate();
        map=msg.getMap("main", "passive");
      } catch(Exception x) {
        x.printStackTrace();
        return;
      }
    }
    
    Iterator iter=subscriptions.iterator();
    Subscriber s;
    while (iter.hasNext()) {
      s = (Subscriber)iter.next();
      try {
        IFilter filter = ((FilteredSubscription)s.getParam()).getFilter();
        boolean match = false;
        if (filter instanceof IActiveFilter) {
          // filter against the activated object          
          Object obj = msg.getObject();
          try {
            // we will get an exception if we cannot cast the class
            Class filteredClass = Class.forName(((IActiveFilter)filter).getFilteredClassName());
            filteredClass.cast(obj);
            match = filter.matches(obj);
	      } catch (ClassCastException cce) {
	      }
        }
        else {
          // filter against the passivated TypedMap
          match = filter.matches(map);
        }

        if (match && (ctx.channel.getSession()!=s.getChannel().getSession() ||
            (ctx.publisher!=null && ctx.publisher.getLocalLoopback())))
        {
          Mundo.bcl.send(s, msg, ctx);
        }

      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
  
  public static FilteredSet contQuery(IFilter f, Session session, FilteredSet.ISignal handler) throws Exception
  {
    FilteredSet fs = new FilteredSet(session);
    if (handler!=null)
      Signal.connect(FilteredSet.ISignal.class, fs, handler);
    fs.setFilter(f);
    Subscriber sub = FilteredSubscription.subscribe(session, f);
    sub.setReceiver(fs);
    sub.enable();

    DoIServiceManager doAllSvcMan = new DoIServiceManager();
    Signal.connect(doAllSvcMan, session.publish("lan", "lan.sd"));
    doAllSvcMan.advertiseServices(DoObject.ONEWAY);
//    advertiseServices();

    return fs;
  }

/*
  public FilteredSet query(IFilter sif, Session session) throws Exception
  {
    log.fine("query: "+sif);
    ResultSet rs = new ResultSet(session);
    TypedMapFilter filter = sif._getFilter();
    rs.setFilter(filter);
    TypedMapFilter tmf = new TypedMapFilter();
    tmf.putMapFilter("object", filter);
    Subscriber sub = ContentSubscription.subscribe(getSession(), tmf);
    sub.setReceiver(rs);
    sub.enable();

    if (doAllSvcMan == null)
    {
      doAllSvcMan = new DoIServiceManager();
      Signal.connect(doAllSvcMan, getSession().publish("lan", "lan.sd"));
    }
    doAllSvcMan.advertiseServices(DoObject.ONEWAY);
    advertiseServices();

    return rs;
  }
*/

#ifdef CFG_JAVA15
  private ArrayList<Subscriber> subscriptions = new ArrayList<Subscriber>();
#else
  private ArrayList subscriptions = new ArrayList();
#endif
}
