/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.net;

import java.util.HashMap;
import java.util.ArrayList;
import java.util.Random;
import java.io.DataOutputStream;
import java.io.FileOutputStream;

import org.mundo.rt.GUID;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.Message;
import org.mundo.rt.ProtocolStack;
import org.mundo.rt.Service;
import org.mundo.rt.TypedArray;
import org.mundo.rt.TypedMap;
import org.mundo.rt.Logger;

/**
 * This handler writes a trace file to monitor traffic.
 * 
 * @author erwin
 */
public class TraceHandler extends Service implements IMessageHandler emits IMessageHandler
{
  public TraceHandler()
  {
  }
  /**
   * Called on initialization of the service.
   */
  public void init() // Service
  {
    super.init();
    streams = new HashMap<String, DataOutputStream>();
  }
  /**
   * Called on shutdown of the service.
   */
  public void shutdown() // Service
  {
    // close all streams
    for (DataOutputStream os : streams.values())
    {
      try
      {
        os.close();
      }
      catch(Exception x)
      {
        log.exception(x);
      }
    }
    super.shutdown();
  }
  /**
   * Called when a packet travels down the stack.
   */
  public boolean down(Message msg)
  {
    writeTrace(msg);
    return emit.down(msg);
  }
  /**
   * Called when a packet travels up the stack.
   */
  public boolean up(Message msg)
  {
    writeTrace(msg);
    return emit.up(msg);
  }
  /**
   * Writes a trace file entry for the specified message.
   */
  private void writeTrace(Message msg)
  {
    DataOutputStream os = getStream(msg);
    try
    {
      // write the record size in number of bytes
      os.writeInt(12);
      // write a timestamp (8 bytes)
      os.writeLong(System.currentTimeMillis());
      // write the payload size
      os.writeInt(msg.getBlob("all", "bin").size());
    }
    catch(Exception x)
    {
      log.exception(x);
    }
  }
  /**
   * Retrieves the trace filename from the options of the current message
   * handler and returns a stream for writing to that file.
   */
  private DataOutputStream getStream(Message msg)
  {
    String filename = null;
    TypedMap opts = msg.getHandler().getOptions();
    if (opts!=null)
      filename = opts.getString("filename", filename);
    DataOutputStream os = streams.get(filename);
    if (os==null)
    {
      try
      {
        os = new DataOutputStream(new FileOutputStream(filename));
        streams.put(filename, os);
      }
      catch(Exception x)
      {
        log.exception(x);
      }
    }
    return os;
  }
  
  private HashMap<String, DataOutputStream> streams;
  private Logger log = Logger.getLogger("trace");
}
