/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.rt;

#ifdef CFG_CLDC
import java.util.Hashtable;
#else
import java.util.HashMap;
#endif

#ifdef CFG_CHECKED_BUILD
#  define LOG log
#else
#  define LOG //
#endif

import org.mundo.agent.MobilityException;
import org.mundo.rt.TypedMap;

/**
 * <p><code>ServerStub</code> is the abstract base class from which all server-side
 * stubs are derived. Server-side stub classes for specific (user) classes are
 * usually generated by using <code>idlc</code>. The compiler uses the prefix
 * 'Srv' for server stubs.
 *
 * @author Erwin Aitenbichler
 */
public abstract class ServerStub
{
  /**
   * Invokes a method on the specified object.
   * @param o  the target object.
   * @param m  a map containing information about the originator, call mode,
   *           parameter types, and parameter values.
   * @param r  a map containing the response.
   */
  public abstract void invoke(Object o, TypedMap m, TypedMap r);

#ifdef CFG_CLDC
  /**
   * Returns a <code>ServerStub</code> for the specified class name. For example, if the
   * parameter is <code>org.mundo.net.DebugService$LogEntry</code>, the
   * singleton instance of <code>org.mundo.net.SrvDebugService$SrvLogEntry</code>
   * is returned.
   *
   * @param className  the fully qualified class or interface name.
   * @return  the server stub suitable for the specified class name.
   * @throws ClassNotFoundException  if the class cannot be located.
   * @throws InstantiationException  if the server stub class is invalid,
   *   has no nullary constructor; or if the instantiation fails for some
   *   other reason.
   * @throws IllegalAccessException  if the server stub class or its
   *   nullary constructor is not accessible.
   */
  public static synchronized ServerStub forName(String className)
         throws ClassNotFoundException, InstantiationException, IllegalAccessException
#else
  /**
   * Returns a <code>ServerStub</code> for the specified class name. For example, if the
   * parameter is <code>org.mundo.net.DebugService$LogEntry</code>, the
   * singleton instance of <code>org.mundo.net.SrvDebugService$SrvLogEntry</code>
   * is returned.
   *
   * @param className  the fully qualified class or interface name.
   * @param classLoader  the <code>ClassLoader</code> to use. Can be set to <code>null</code>.
   * @return  the server stub suitable for the specified class name.
   * @throws ClassNotFoundException  if the class cannot be located.
   * @throws InstantiationException  if the server stub class is invalid,
   *   has no nullary constructor; or if the instantiation fails for some
   *   other reason.
   * @throws IllegalAccessException  if the server stub class or its
   *   nullary constructor is not accessible.
   */
  public static synchronized ServerStub forName(String className, ClassLoader classLoader)
         throws ClassNotFoundException, InstantiationException, IllegalAccessException
#endif
  {
    ServerStub stub = (ServerStub)stubs.get(className);
    if (stub != null)
    {
      if (classLoader!=null && classLoader!=stub.getClass().getClassLoader())
        log.info("code update detected: " + className);
      else
        return stub;
    }
  
    // Build name of server stub class. Everything but package names must
    // be prefixed with 'Srv'. (No regexps used, because of 1.2 compat)
    String s = className;
    String prefix = "Srv";
    int i = s.lastIndexOf('.');
    if (i>0)
      s = s.substring(0, i+1)+prefix+s.substring(i+1);
    else
      s = prefix+s;
    for (i=0; i<s.length(); i++)
    {
      if (s.charAt(i)=='$')
      {
        s = s.substring(0, i+1)+prefix+s.substring(i+1);
        i += prefix.length();
      }
    }
#ifndef CFG_CLDC
    if (classLoader!=null)
      stub = (ServerStub)Class.forName(s, true, classLoader).newInstance();
    else
#endif
      stub = (ServerStub)Class.forName(s).newInstance();
    stubs.put(className, stub);
    return stub;
  }

  /**
   * Called by a server stub implementation when an exception has been caught.
   * <code>exceptionOccured</code> sends a reply message containing the
   * exception to the client for non-oneway calls.
   * For oneway calls, the stack trace is printed to <code>System.out</code>.
   *
   * @param x  the exception thrown by the target object's implementation.
   * @param o  the target object.
   * @param m  a map containing information about the originator, call mode,
   *           parameter types, and parameter values.
   * @param r  a map containing the response.
   */
  protected void exceptionOccured(Exception x, Object o, TypedMap m, TypedMap r)
  {
    if (x instanceof MobilityException)
    {
      LOG.fine("ignoring MobilityException");
      return;
    }
    boolean oneWay = m.getBoolean("oneWay", false);
    if (oneWay)
    {
      log.log(log.WARNING, "Exception on server side during ONEWAY RMC", x);
    }
    else
    {
      log.log(log.WARNING, "Exception on server side during RMC", x);

      r.put("request", "ErrorResponse");
      r.put("callId", m.get("callId"));
      r.put("exceptionClass", x.getClass().getName());
      r.put("exceptionText", x.toString());
      r.put("exceptionJavaObject", x);
//      Message rm=new Message(r);
//      s.send(m.getGUID("sessionId"), rm);
    }
  }

#ifdef CFG_CLDC
  private static Hashtable stubs = new Hashtable();
#else
#ifdef CFG_JAVA15
  private static HashMap<String,ServerStub> stubs = new HashMap<String,ServerStub>();
#else
  private static HashMap stubs = new HashMap();
#endif
#endif
  private static Logger log = Logger.getLogger("ss");
}
