/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.rt;

#ifdef CFG_CLDC
import java.util.Enumeration;
#else
import java.util.Iterator;
#endif

#ifdef CFG_JAVA15
import java.util.HashMap;
#endif

/**
 * <p><code>DoObject</code> is the abstract base class from which all client-side
 * stubs are derived. Client-side stub classes for specific (user) classes are
 * usually generated by using <code>mcc</code>. While exposing the same interface
 * as the original class, a client-side stub forwards method calls to the
 * remote object. The <code>DoObject</code> class also implements the
 * <code>java.lang.Object</code> behavior for remote objects. It provides the
 * remote semantics of <code>Object</code> by implementing <code>hashCode</code>,
 * <code>equals</code>, and <code>toString</code>.</p>
 *
 * <p>The prefix character <code>_</code> is used to mark methods specific to
 * the stub implementation and to prevent name clashes with user method
 * names. The <code>mcc</code> compiler uses the prefix 'Do' (Distributed Object)
 * for generated client stub classes.</p>
 *
 * <p>For each exported method, <code>mcc</code> generates an additional
 * method in the client stub that has an additional parameter to pass options.
 * For example, consider the following source file:</p>
 *
 * <pre>
 * &#064;mcRemote
 * public class Foo
 * {
 *   ...
 *   &#064;mcMethod
 *   public int add(int x, int y);
 * }</pre>
 *
 * <code>mcc</code> will create the following client stub, also named
 * distributed object (Do):
 *
 * <pre>
 * public class DoFoo
 * {
 *   ...
 *   public int add(int x, int y) throws Exception;
 *   public AsyncCall add(int x, int y, DoObject.Options options) throws Exception;
 * }</pre>
 *
 * <p>The first <code>add</code> method performs a synchronous remote method call,
 * the second method with the additional parameter can be used to perform
 * either synchronous (see constant <code>SYNC</code>), asynchronous (see constant <code>ASYNC</code>)
 * or one-way (see constant <code>ONEWAY</code>) calls. Note that objects that are passed
 * as parameters may not change while the call is in progress. If a mutable
 * object is passed as a parameter to a one-way or asynchronous method call
 * and this object is modified before the call finishes, the behaviour is
 * undefined. Thus, parameter objects passed in one-way or asynchronous calls
 * should be immutable, or copies should be passed as parameters instead.</p>
 *
 * @author Erwin Aitenbichler
 */
public class DoObject implements IActivate
#ifndef CFG_CLDC
	, Cloneable
#endif
{
  /**
   * Implement this interface to keep track of the connection state of an object.
   */
  public interface IConn
  {
    public void objectConnected();
    public void objectDisconnected();
  }

  /**
   * Initializes a new remote object reference.
   */
  public DoObject()
  {
    timeout = DEFAULT_TIMEOUT;
  }
  /**
   * Initializes a new remote object reference.
   */
  DoObject(org.mundo.rt.Session session, Object obj) throws org.mundo.rt.RMCException
  {
    timeout = DEFAULT_TIMEOUT;
    _bind(session, obj);
  }
  /**
   * Returns a copy of this remote object reference.
   */
#ifndef CFG_CLDC
  public Object clone()
  {
    try
    {
      DoObject c = (DoObject)super.clone();
      // clear publisher, subscriber and connection state
      c.publisher = null;
      c.subscriber = null;
      c.connHandler = null;
      c.state = STATE_NULL;
      // clear session for the moment... should we keep it?
      c.session = null;
      return c;
    }
    catch(CloneNotSupportedException x)
    {
      // this can't happen
      Logger.getLogger("do").exception(x);
    }
    return null;
  }
#endif
  /**
   * Compares two remote objects for equality.
   * Returns a boolean that indicates whether this remote object is
   * equivalent to the specified <code>Object</code>. Two <code>DoObject</code>s
   * are equivalent, if they publish to the same channel.
   * If the specified <code>Object</code> is not itself an instance of
   * <code>DoObject</code>, then this method delegates by returning the result
   * of invoking the <code>equals</code> method of its parameter with this
   * remote object as the argument.
   * @param  obj  the Object to compare with.
   * @return      true if these Objects are equal; false otherwise.
   */
  public boolean equals(Object obj)
  {
    if (obj==this)
      return true;
    if (obj==null)
      return false;
    if (obj instanceof DoObject)
    {
      DoObject cs=(DoObject)obj;
      // modified by AHA: if there is a local object, then the two ClientStubs are equal if they are pointing to the same object
      if (localObj!=null && localObj==cs.localObj)
        return true;
      if (publisher==cs.publisher && subscriber==cs.subscriber)
        return true;
      boolean ret = true;
      if (publisher!=null)
        ret = publisher.getChannel().equals(cs.publisher.getChannel());
      if (subscriber!=null && ret)
        ret = subscriber.getChannel().equals(cs.subscriber.getChannel());
      return ret;
    }
    return obj.equals(this);
  }
  /**
   * Returns a hashcode for a <code>DoObject</code>. Two remote object stubs
   * that publish to the same channel will have the same hash code.
   * @return  a hash code value for this stub.
   */
  public int hashCode()
  {
    if (publisher==null)
      // modified by AHA: because ClientStubs pointing to the same local object are equal,
      // the identity-hashcode of this local object is used instead of a constant
      // that way guarantees that the hashcodes of two ClientStubs pointing to the same
      // local object have the same hashcode
      return System.identityHashCode(localObj);
    return publisher.getChannel().hashCode();
  }
  /**
   * Returns a string that represents the reference of this remote object.
   * @return  a string containing the external class name and the
   *          channel name this stub publishes to.
   */
  public String toString()
  {
    if (session!=null)
      return _getExternalTypeName()+"@"+zoneName+":"+channelName;
    else
      return _getExternalTypeName()+"@"+zoneName+":"+channelName+"(unbound)";
  }
  /**
   * Assigns a publisher to this stub. The publisher will be used to send
   * requests to the remote object.
   * @param p  the publisher object to assign.
   */
  public void _setPublisher(Publisher p)
  {
    publisher = p;
    session = publisher.getSession();
    publisher.setSender(this);
    if (rmcService!=null)
      rmcService.importObject(this);
  }
  /**
   * Returns the publisher object this stub is using.
   * @return  the publisher object assigned to this stub.
   */
  public Publisher _getPublisher()
  {
    if (publisher==null)
    {
#ifdef CFG_CHECKED_BUILD
      if (session==null)
        throw new IllegalStateException("no session defined while trying to create publisher");
#endif
      publisher = session.publish(zoneName, channelName);
      publisher.setSender(this);
    }
    return publisher;
  }
  /**
   * 
   */
  public String _getChannelName()
  {
    return channelName;
  }
  /**
   * Sets the timeout for calls. Synchronous remote method calls will fail
   * if the server does not respond within this timeout period. The default
   * timeout value is 10000 ms.
   * @param ms  the timeout value in milliseconds.
   */
  public void _setTimeout(int ms) throws IllegalArgumentException
  {
    timeout=ms;
    if (timeout<1)
      throw new IllegalArgumentException("timeout must be >=1");
  }
  /**
   * Returns the timeout value.
   * @return  the timeout value in milliseconds.
   */
  public int _getTimeout()
  {
    return timeout;
  }
  /**
   * Returns the server-side stub for this client-side stub.
   */
  public ServerStub _getServerStub()
  {
    throw new UnsupportedOperationException();
  }
  /**
   * Binds a local object to a session in order to make it accessible from
   * remote parties. If the local object is a <code>Service</code>,
   * then the GUID of the service is used as channel name. For all other objects
   * a new random GUID is generated. A server stub for the specified local object
   * is then created and subscribed using the GUID as channel name.
   * @param s    the session to bind the object to.
   * @param obj  the local object.
   */  
  public void _bind(Session s, Object obj) throws RMCException
  {
    session = s;
    localObj = obj;
    zoneName = "lan";

    if (localObj instanceof Service)
    {
      channelName = ((Service)localObj).getServiceId().toString();
      // The zone name for the subscription must be 'lan'.
      // It would be better to use the same zone name as for the service:
      //   zoneName = ((Service)localObj).getServiceZone();
      // However, this would require to update the subscriptions of all
      // DoObjects attached to the service each time the service zone is
      // changed, which is not implemented.
    }
    else
      channelName = new GUID().toString();

    if (session != null)
      Signal.connect(subscriber = session.subscribe(zoneName, channelName), localObj);
  }
  /**
   * Associates this distributed object with the specified session.
   */
  public void _bind(Session s)
  {
#ifdef CFG_CHECKED_BUILD
    if (publisher!=null || subscriber!=null)
      throw new IllegalStateException("cannot change the session of a distributed object "+
          "when there are already publishers or subscribers attached");
#endif
    session = s;
  }
  /**
   * Unbinds the object from its associated subscriber and unsubscribes the
   * subscriber.
   */
  public void _unbind()
  {
    if (subscriber!=null)
    {
      subscriber.getSession().unsubscribe(subscriber);
      subscriber = null;
    }
  }
  /**
   * Used internally to cast from one Do-type to another Do-type.
   */
  protected void _assign(DoObject o)
  {
    channelName = o.channelName;
    zoneName = o.zoneName;
    localObj = o.localObj;
    session = o.session;
    subscriber = o.subscriber;
    publisher = o.publisher;
    timeout = o.timeout;
  }
/*
  public void _assign(Session session, Class ifc, Object localObj) throws RMCException
  {
    String zone="lan";
    String channel=new GUID().toString();
    session.subscribe(zone, channel, ifc, localObj);
    session.publish(zone, channel, this);
  }
*/
  /**
   * Returns the target object if it resides locally.
   * @return  the target object if it resides locally;
   *          <code>null</code> otherwise.
   */
  public Object _getLocalObject()
  {
    return localObj;
  }
  /**
   * Returns the external type name for this distributed object class.
   * The external type name serves as a globally unique class name that
   * is shared between different programming language implementations of
   * MundoCore.
   * @return  a string containing the external class name.
   * @see     IActivate
   */
  public String _getExternalTypeName() // IActivate
  {
    return getClass().getName();
  }
  /**
   * Returns the target class or interface name this stub is built for.
   * @return  the target class or interface name.
   */
  public String _getInterfaceName()
  {
    return "java.lang.Object";
  }
  /**
   * Converts the stub to its external representation.
   * @param m  the map to write the object's external representation into.
   * @see      IActivate
   */
  public void _passivate(org.mundo.rt.TypedMap m) throws Exception // IActivate
  {
    m.putString("channel", channelName);
    m.putString("zone", zoneName);
    m.putInt("timeout", timeout);
  }
  /**
   * Initializes a distributed object from its external representation.
   * @param m  the map containing the object's external representation.
   */
  public void _activate(TypedMap m, TypedMap ctx) throws Exception // IActivate
  {
    try
    {
      channelName = m.getString("channel");
      zoneName = m.getString("zone");
      timeout = m.getInt("timeout", DEFAULT_TIMEOUT);

      // get session from activation context. Because DoObjects are always
      // bound to sessions, it is not possible to activate without knowing
      // the related session.
      if (ctx==null)
        return;
      session = (Session)ctx.getObject("session", null);
      if (session==null)
        return;

      // modified by AHA: activation checks if there is a local object present already
      // deserialization adjusted appropriately
      Channel c = new Channel(zoneName, channelName);
      
      // iterate through all published channels of this session and check if there is already a publisher
      // FIXME: once Session has a list of exported objects, use this instead of the current approach
#ifdef CFG_CLDC
      for(Enumeration e = session.getSubscribers().elements(); e.hasMoreElements(); ) {
        Subscriber s = (Subscriber)e.nextElement();
#else
      for(Iterator i = session.getSubscribers().iterator(); i.hasNext(); ) {
        Subscriber s = (Subscriber)i.next();
#endif
        if (c.equals(s.getChannel()) && s.getReceiver() instanceof ObjectAdapter) {
          // there is already an object adapter for the given channel locally
          // <=> the client sub was created locally
          localObj = ((ObjectAdapter)s.getReceiver()).getTarget();
          // do not publish local information, it is unnecessary
          return;
        }
      }

      // this will only be called if there is no local object for this client stub
      publisher = session.publish(zoneName, channelName);
      publisher.setSender(this);
    }
    catch(Exception x)
    {
      Logger.getLogger("do").exception(x);
    }
  }
  public void _testCompatibility() throws RMCException
  {
    String ifName = _getInterfaceName();
#ifdef CFG_CHECKED_BUILD
    if (ifName==null)
      throw new IllegalStateException("interface is not set");
#endif
    TypedMap req=new TypedMap();
    req.put("sysRequest", "testCompatibility");
    AsyncCall call=new AsyncCall(this, ifName, null, req);
    call.invoke();
    call.waitForReply();
    Exception x=call.getException();
    if (x!=null)
      throw (RMCException)x;
  }
  public String _getMethods() throws RMCException
  {
    String ifName = _getInterfaceName();
#ifdef CFG_CHECKED_BUILD
    if (ifName==null)
      throw new IllegalStateException("interface is not set");
#endif
    TypedMap req=new TypedMap();
    req.put("request", "_getMethods");
    req.put("ptypes", "");
    AsyncCall call=new AsyncCall(this, ifName, null, req);
    call.invoke();
    call.waitForReply();
    Exception x=call.getException();
    if (x!=null)
      throw (RMCException)x;
    return (String)call.getObj();
  }
  public String _getFields(String className) throws RMCException
  {
    TypedMap req = new TypedMap();
    req.put("sysRequest", "getFields");
    req.put("className", className);
    AsyncCall call = new AsyncCall(this, _getInterfaceName(), null, req);
    call.invoke();
    call.waitForReply();
    Exception x = call.getException();
    if (x!=null)
      throw (RMCException)x;
    return (String)call.getObj();
  }
  public TypedArray _getInterfaces() throws RMCException
  {
    TypedMap req = new TypedMap();
    req.put("sysRequest", "getInterfaces");
    AsyncCall call = new AsyncCall(this, null, null, req);
    call.invoke();
    call.waitForReply();
    Exception x = call.getException();
    if (x!=null)
      throw (RMCException)x;
    return (TypedArray)call.getObj();
  }
  /**
   * Returns the DoObject for the specified session and object.
   */
#ifdef CFG_CLDC
  protected static DoObject _getDoObject(Session session, String stubClassName, Object obj)
  {
    return session.getDoObject(stubClassName, obj);
  }
#else
  protected static DoObject _getDoObject(Session session, Class stubClass, Object obj)
  {
    return session.getDoObject(stubClass, obj);
  }
#endif
  public static DoObject _base_of(Session session, Object obj)
  {
    if (session == null)
      return new DoObject(null, obj);
#ifndef CFG_CLDC
    DoObject cs = (DoObject)_getDoObject(session, DoObject.class, obj);
#else
    DoObject cs = (DoObject)_getDoObject(session, "org.mundo.rt.DoObject", obj);
#endif
    if (cs == null)
    {
      cs = new DoObject(session, obj);
      _putDoObject(session, obj, cs);
    }
    return cs;
  }
  public static DoObject _base_of(Service svc)
  {
    return _base_of(svc.getSession(), svc);
  }
  /**
   * Stores the DoObject for the specified session and object.
   */
  protected static void _putDoObject(Session session, Object obj, DoObject cs)
  {
    session.putDoObject(obj, cs);
  }
  /**
   * Sets the connection handler. The connection handler receives events once the
   * stub was successfully connected or the stub has lost connection.
   */
  public void _setConnHandler(IConn h)
  {
    connHandler=h;
  }
  /**
   * Returns the connection handler.
   */
  public IConn _getConnHandler()
  {
    return connHandler;
  }
  /**
   * Sets the state.
   */
  public void _setState(int s)
  {
    state=s;
  }
  /**
   * Gets the state.
   */
  public int _getState()
  {
    return state;
  }
#ifdef CFG_JAVA15
  /**
   * Gets the specified facet.
   */
  public Facet _getFacet(Class cls)
  {
    if (facets==null)
      return null;
    return facets.get(cls);
  }
  /**
   * Sets the specified facet.
   */
  public void _addFacet(Facet f)
  {
    if (facets==null)
      facets = new HashMap<Class,Facet>();
    facets.put(f.getClass(), f);
  }
#endif
  /**
   * Options can be specified as last parameter when doing a remote method call.
   */
  public static class Options
  {
    Options(int v)
    {
      value=v;
    }
    public Options add(Options o)
    {
      return new Options(value | o.value);
    }
    public boolean test(Options o)
    {
      return (value & o.value)>0;
    }
    int value;
  }
  
  private static final int CALL_SYNC = 1;
  private static final int CALL_ASYNC = 2;
  private static final int CALL_ONEWAY = 4;
  private static final int CALL_CREATEONLY = 8;
  private static final int CALL_PASSIVE_PARAMS = 0x10;
  private static final int CALL_MULTICAST = 0x20;
  
  /**
   * Specified as an option to do a synchronous remote method call.
   */
  public static final Options SYNC = new Options(CALL_SYNC);
  /**
   * Specified as an option to do a asynchronous remote method call.
   */
  public static final Options ASYNC = new Options(CALL_ASYNC);
  /**
   * Specified as an option to do a oneway remote method call when
   * there is a single receiver. If there are multiple receivers,
   * the behavior will be that of an anycast.
   */
  public static final Options ONEWAY_UNICAST = new Options(CALL_ONEWAY);
  /**
   * Specified as an option to do a oneway remote method call when
   * there are multiple receivers.
   */
  public static final Options ONEWAY_MULTICAST = new Options(CALL_ONEWAY|CALL_MULTICAST);
  /**
   * Specified as an option to do a oneway remote method call.
   * The default behavior is <code>ONEWAY_MULTICAST</code>
   * (for backward compatibility).
   */
  public static final Options ONEWAY = ONEWAY_MULTICAST;
  /**
   * Specified as an option to create only the <code>AsyncCall</code>
   * object without invocation. The client can then register a result
   * listener before invoking the call.
   */
  public static final Options CREATEONLY = new Options(CALL_CREATEONLY);
  /**
   * Specified as an option to indicate that the passed parameters to
   * a call are in passive representation.
   */
  public static final Options PASSIVE_PARAMS = new Options(CALL_PASSIVE_PARAMS);
  /**
   * Specified as an additional option to multicast requests.
   * In most cases you should not use this option directly.
   * Use <code>ONEWAY_UNICAST</code> or <code>ONEWAY_MULTICAST</code> instead.
   */
  public static final Options MULTICAST = new Options(CALL_MULTICAST);

  public static final int STATE_NULL = 0;
  public static final int STATE_DISCONNECTED = 1;
  public static final int STATE_CONNECTED = 2;
     
  /**
   * the channel name.
   */
  private String channelName;
  /**
   * the zone name.
   */
  private String zoneName;
  /**
   * the referenced local object.
   */
  protected Object localObj = null;
  /**
   * the session this DoObject is associated with.
   */
  protected Session session;
  /**
   * the publisher object.
   */
  protected Publisher publisher;
  /**
   * the subscriber object.
   */
  protected Subscriber subscriber;
  /**
   * the timeout value for RMC, in milliseconds.
   */
  protected int timeout;

//  protected HashMap<Class,> facets = new HashMap<>();

  /**
   * the connected state of the object. One of <code>STATE_CONNECTED</code>
   * or <code>STATE_DISCONNECTED</code>.
   */
  private int state = STATE_NULL;
  /**
   * the connected state listener.
   */
  private IConn connHandler = null;
#ifdef CFG_JAVA15
  private HashMap<Class,Facet> facets;
#endif

  public static IRMCService rmcService;
  private final static int DEFAULT_TIMEOUT = 10000;
}
