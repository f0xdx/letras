/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.util.plugins;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

#ifdef CFG_JAVA15
import org.mundo.annotation.mcField;
import org.mundo.annotation.mcSerialize;
#endif
import org.mundo.rt.IActivate;
import org.mundo.rt.Logger;
import org.mundo.rt.Mundo;
import org.mundo.rt.TypedArray;
import org.mundo.rt.TypedMap;
import org.mundo.service.ServiceManager.OptServiceManager;
import org.mundo.util.DirectoryMonitor;
import org.mundo.util.IDirectoryMonitor;
import org.mundo.util.SyntaxErrorException;
import org.mundo.util.plugins.VirtualDirectoryJarFile;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

#ifdef CFG_JAVA15
  #define Map_File_PluginManager_ Map<File, PluginManager>
  #define HashMap_File_PluginManager_ HashMap<File, PluginManager>
  #define Map_String_List_IPluginMonitorIPluginHandler__ Map<String, List_IPluginMonitorIPluginHandler_>
  #define HashMap_String_List_IPluginMonitorIPluginHandler__ HashMap<String, List_IPluginMonitorIPluginHandler_>
  #define Map_File_Document_ Map<File, Document>
  #define HashMap_File_Document_ HashMap<File, Document>
  #define List_IPluginMonitorIPluginHandler_ List<IPluginMonitor.IPluginHandler>
  #define ArrayList_IPluginMonitorIPluginHandler_ ArrayList<IPluginMonitor.IPluginHandler>
  #define EMPTY_LIST emptyList()
#else
  #define Map_File_PluginManager_ Map
  #define HashMap_File_PluginManager_ HashMap
  #define Map_String_List_IPluginMonitorIPluginHandler__ Map
  #define HashMap_String_List_IPluginMonitorIPluginHandler__ HashMap
  #define Map_File_Document_ Map
  #define HashMap_File_Document_ HashMap
  #define List_IPluginMonitorIPluginHandler_ List
  #define ArrayList_IPluginMonitorIPluginHandler_ ArrayList
#endif

/**
 * A PluginManager monitors a given directory for plugins. Plugins which are
 * dropped there are newly registered to the system. Plugins which are deleted
 * are unregistered from the system.
 * 
 * The files for dropped plugins may remain locked in the future - currently
 * they are not locked.
 * 
 * @author AHa
 */
public class PluginManager implements IDirectoryMonitor.IDirectoryModification {

  /**
   * Options to configure PluginManager
   */
  @mcSerialize
  public static class OptPluginManager implements IActivate {

    /**
     * Should it be possible to use subdirectories similarly to JAR files?
     */
    @mcField(name = "enable-subdirectories", optional = true)
    public boolean enableSubdirectories = false;

    /**
     * A list of files that should be explicitly denied from being searched.
     */
    @mcField(name = "exclude", optional = true)
    public TypedArray exclude;
  }

  /**
   * Options to configure exclude directories.
   */
  @mcSerialize
  public static class ConfExclude implements IActivate {

    public String path;
  }
  
  /**
   * The configuration for plugin managers on this host
   */
  private static OptPluginManager conf;

  /**
   * The name of the plugin configuration file inside the JAR file
   */
  private static final String CONFIG_LOCATION = "META-INF/plugin.xml";

  /**
   * The Namespace of the plugin file
   */
  private static final String PLUGIN_NAMESPACE = "http://mundo.org/2004/plugin/";

  /**
   * The Logger used to print all log messages on.
   */
  private static Logger log = Logger.getLogger("plugins");

  /**
   * This is a Map <File, PluginManager> that contains a plugin manager for the
   * directory it monitors
   */
  private static Map_File_PluginManager_ managers = new HashMap_File_PluginManager_();

  /**
   * The directory to monitor for plugins.
   */
  private File dir;

  /**
   * This Map&lt;String, IPluginHandler> contains the plugin handlers for all
   * namespaces.
   */
  private Map_String_List_IPluginMonitorIPluginHandler__ handlers = new HashMap_String_List_IPluginMonitorIPluginHandler__();

  /**
   * This Map&lt;File, Document> contains the plugin.xml documents for all
   * plugins registered. This is necessary for unregistering plugins.
   */
  private Map_File_Document_ loadedPlugins = new HashMap_File_Document_();

  /**
   * A CheckAction is an inner class doing a closure for block operations.
   * 
   * @author AHa
   */
  private interface CheckAction {

    /**
     * Checks if the object might be used or not
     * 
     * @param o the object to be checked
     * @return true if the object is valid and may be used
     */
    public boolean check(Object o);

  }

  /**
   * A HandlerIterator is used for implementing a closure on a List-factory
   */
  private interface HandlerListFactory {

    /**
     * Gives a non-null list of handlers to be used for a given namespace
     * 
     * @param namespace the namespace currently selected
     * @return a List <IPluginMonitor.IPluginHandler>containing plugin handlers
     *         to be notified
     */
    public List_IPluginMonitorIPluginHandler_ handlers(String namespace);
  }
  
  /**
   * Adds a PluginHandler monitoring a given directory. Initially, the handler
   * gets registrations for all plugin files already residing in the directory.
   * After that, modifications in the directory are automatically reflected.
   * 
   * There may be multiple pluginHandlers for a directory and/or namespace. The
   * order in which the pluginRegistered/pluginUnRegistered methods of these
   * handlers are called is not defined.
   * 
   * @param handler plugin handler for the PluginManager
   * @param directory the directory to look for plugins
   * 
   * @throws IOException if <code>directory</code> is no valid directory
   */
  public static void addPluginHandler(final IPluginMonitor.IPluginHandler handler, File directory) throws IOException {
    if(conf == null) {
      conf = (OptPluginManager)Mundo.getConfig().getObject("PluginManager", null);
      if (conf == null)
        conf = new OptPluginManager();
      if(conf.exclude != null)
        // if there are paths to exclude, convert them into absolute form
        for(int i = 0; i < conf.exclude.size(); i++) {
          try {
            // try to replace the original string with a nice path string 
            conf.exclude.set(i, new File(conf.exclude.getString(i)).getAbsolutePath());
          } catch(SecurityException e) {
          }
        }
      else
        conf.exclude = new TypedArray();
    }
    
    HandlerListFactory lf = new HandlerListFactory() {
      
      public List_IPluginMonitorIPluginHandler_ handlers(String namespace) {
        if(handler.getNamespaceURI().equals(namespace))
          return Collections.singletonList(handler);
        else
          return Collections.EMPTY_LIST;
      }

    };

    try {
      // try to translate the directory to the canonical path so that duplicates
      // may be eliminated
      directory = directory.getCanonicalFile();
    } catch(Exception e) {
      log.warning("Could not use the canonical path for " + directory + " because of an exception. Will be using default path instead.");
      log.exception(e);
    }
    PluginManager manager = (PluginManager)managers.get(directory);
    if(manager == null)
      managers.put(directory, manager = new PluginManager(directory));
    manager.registerHandler(handler);

    File elements[] = directory.listFiles();
    for(int i = 0; i < elements.length; i++)
      manager.checkFile(elements[i], lf);
  }
  
  /**
   * Removes a PluginHandler that was monitoring the directory. If the handler
   * was registered for monitoring the directory, it will be removed. Other
   * directories monitored by the handler are not affected. If the handler was
   * not monitoring the given directory, the method does nothing.
   * 
   * @param handler plugin handler for the PluginManager
   * @param directory the directory to stop investigating
   * @param notifyUnload if
   *          <code>true</true>, the pluginUnRegistered method of the unloaded
   * handler will be called.
   */
  public static void removePluginHandler(final IPluginMonitor.IPluginHandler handler, File directory, boolean notifyUnload) {
    PluginManager manager = (PluginManager)managers.get(directory);
    if(manager == null)
      return;
    
    manager.unregisterHandler(handler, notifyUnload);
  }

  /**
   * Constructs a new PluginManager that is monitoring a given directory.
   * Initially, the directory is scanned and all plugins found get registered.
   * After that, modifications in the directory are automatically reflected.
   * 
   * @param directory the directory to look for plugins
   * @throws IOException if <code>directory</code> is no valid directory
   */
  private PluginManager(File directory) throws IOException {
    if(!directory.exists())
      throw new IOException(directory + " does not exist");
    if(!directory.isDirectory())
      throw new IOException(directory + " is not a directory");
    dir = directory;

    log.fine("Creating " + PluginManager.class.getName() + " for the directory \"" + directory + "\"");

    DirectoryMonitor.monitorDirectory(directory, this);
  }

  /**
   * Monitors the PluginManager's directory for newly added JAR-Files. A new JAR
   * file is read and its classes get loaded into the system.
   * 
   * This method is supposed to be called from the DirectoryMonitor only.
   * 
   * @see org.mundo.util.IDirectoryMonitor.IDirectoryModification#fileAdded(java.io.File,
   *      java.io.File)
   */
  public void fileAdded(File directory, File file) {
    if(!directory.equals(dir))
      return;

    checkFile(file, new HandlerListFactory() {

      public List_IPluginMonitorIPluginHandler_ handlers(String namespace) {
#ifdef CFG_JAVA15
        List_IPluginMonitorIPluginHandler_ handlerlist = handlers.get(namespace);
#else
        List_IPluginMonitorIPluginHandler_ handlerlist = (List_IPluginMonitorIPluginHandler_)handlers.get(namespace);
#endif
        if(handlerlist != null)
          return handlerlist;
        else
          return Collections.EMPTY_LIST;
      }

    });
  }
  
  /**
   * Opens a file or directory as a JAR file and returns that file. This method
   * takes into account the configuration settings for the plugin manager and
   * does not try to open files that are disallowed either by being
   * subdirectories or by being excluded.
   * 
   * @param file the file that should be opened
   * @return the JAR file pointing to the file or directory or {@code null} if
   *         either no file was present or if the file access was disallowed
   * @throws IOException if there was another error than having the access
   *           denied
   */
  private JarFile openJAR(File file) throws IOException {
    if(conf.exclude.contains(file.getAbsolutePath())) {
      log.info("Ignoring the file " + file.getAbsolutePath() + " because of the node exclude configuration");
      return null;
    }
    if(file.isFile())
      return new JarFile(file);
    if(file.isDirectory()) {
      if(conf.enableSubdirectories)
        return new VirtualDirectoryJarFile(file);
      log.info("Ignoring the directory " + file.getAbsolutePath() + " because the node is not set up to handle subdirectories");
    }
    return null;
  }

  /**
   * Monitors the PluginManager's directory for newly added JAR-Files. A new JAR
   * file is read and its classes get loaded into the system. The
   * 
   * @param file the newly added file
   * @param listfactory a HandlerListFactory passed along to the parsePluginXML
   *          method
   */
  private void checkFile(File file, HandlerListFactory listfactory) {
    log.fine("Found file \"" + file + "\" inside \"" + dir + "\". Checking for plugin features inside the file or directory.");
    
    try {
      JarFile jf = openJAR(file);
      if(jf != null) {
        log.finer("Trying to retrieve the configuration out of " + file);
        
        JarEntry je = jf.getJarEntry(CONFIG_LOCATION);
        JarClassLoader loader = new JarClassLoader(file);
        if(je != null)
          try {
            log.fine("Parsing " + CONFIG_LOCATION);
            parsePluginXML(file, new InputSource(jf.getInputStream(je)), jf, loader, listfactory);
            log.fine("Parsing done");
          } catch(SyntaxErrorException e1) {
            log.info("The " + CONFIG_LOCATION + " file had syntax errors in it. Ignoring .jar file.");
            log.exception(e1);
          }
          jf.close();
        } else
            log.fine("The file does not contain a " + CONFIG_LOCATION + " file");
      } catch(IOException e) {
        // An IOException will be thrown if the file is not a JAR file.
        // In this case, just ignore the file that was added (done by catching
        // the exception) and do nothing
        log.fine("The file ist not a valid JAR file or directory");
      }
  }

  /**
   * This method is supposed to be called from the DirectoryMonitor only.
   * 
   * @see org.mundo.util.IDirectoryMonitor.IDirectoryModification#fileModified(java.io.File,
   *      java.io.File)
   */
  public void fileModified(File directory, File file) {
    // A modified file is treated as a file that was deleted and re-added
    fileRemoved(directory, file);
    fileAdded(directory, file);
  }

  /**
   * This method is supposed to be called from the DirectoryMonitor only.
   * 
   * @see org.mundo.util.IDirectoryMonitor.IDirectoryModification#fileRemoved(java.io.File,
   *      java.io.File)
   */
  public void fileRemoved(File directory, File file) {
    if(!directory.equals(dir))
      return;

    log.fine("Trying to remove file \"" + file + "\" inside \"" + directory + "\". Checking for loaded plugins.");

#ifdef CFG_JAVA15
    Document doc = loadedPlugins.get(file);
#else
    Document doc = (Document)loadedPlugins.get(file);
#endif
    if(doc == null) {
      log.fine("The file is not registered as a loaded plugin. No action was taken.");
      return;
    }

    for(Node child = doc.getDocumentElement().getFirstChild(); child != null; child = child.getNextSibling())
      if(child.getNodeType() == Node.ELEMENT_NODE && child.getNamespaceURI() != null) {
        String uri = child.getNamespaceURI();
#ifdef CFG_JAVA15
        List<IPluginMonitor.IPluginHandler> registered = handlers.get(child.getNamespaceURI());
        if(registered != null)
          for(IPluginMonitor.IPluginHandler handler: registered)
            if(handler != null)
              handler.pluginUnRegistered(uri, child);
#else
        List registered = (List)handlers.get(child.getNamespaceURI());
        if(registered != null)
          for(Iterator i = registered.iterator(); i.hasNext(); ) {
            IPluginMonitor.IPluginHandler handler = (IPluginMonitor.IPluginHandler)i.next();
            if(handler != null)
              handler.pluginUnRegistered(uri, child);
          }
#endif
      }
  }

  /**
   * Parses an XML document out of an input stream.
   * 
   * @param pluginfile the file where the plugin is stored in
   * @param is the input source to parse
   * @param pluginsource the source file for the plugin
   * @param jarclassloader a class loader which is already configured to load
   *          classes out of the package's jar file.
   * @param listfactory a HandlerListFactory producing lists of handlers for a
   *          given namespace. MUST NOT be null
   * @throws SyntaxErrorException if the XML document is malformed
   * @throws IOException if the parsing process failed because of an IOException
   */
  private void parsePluginXML(File pluginfile, InputSource is, JarFile pluginsource, ClassLoader jarclassloader, HandlerListFactory listfactory)
      throws SyntaxErrorException, IOException {
    try {
      // parse the XML out of the source
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setNamespaceAware(true);
      DocumentBuilder builder = factory.newDocumentBuilder();
      Document doc = builder.parse(is);
      boolean success = false;

      if(!PLUGIN_NAMESPACE.equals(doc.getDocumentElement().getNamespaceURI()))
        throw new SyntaxErrorException("XML configuration file has an incorrect namespace");

      for(Node child = doc.getDocumentElement().getFirstChild(); child != null; child = child.getNextSibling())
        if(child.getNodeType() == Node.ELEMENT_NODE && child.getNamespaceURI() != null) {
          String uri = child.getNamespaceURI();
          for(Iterator i = listfactory.handlers(child.getNamespaceURI()).iterator(); i.hasNext();)
            try {
              ((IPluginMonitor.IPluginHandler)i.next()).pluginRegistered(uri, child, pluginsource, jarclassloader);
              // if at least one plugin was registered, we have a success
              success = true;
            } catch(SyntaxErrorException e) {
              // only this part of the plugin registration process went wrong,
              // don't worry too much

              // TODO find out how to print line numbers for node elements
              log.info("The plugin handler for the namespace \"" + child.getNamespaceURI()
                  + "\" indicated that there was a syntax error inside an element");
              log.exception(e);
            }
        }

      // store the parsed DOM away so that one can unload the file
      if(success)
        loadedPlugins.put(pluginfile, doc);

    } catch(ParserConfigurationException e) {
      log.severe("The parser for the " + CONFIG_LOCATION + " file could not be configured correctly.");
      throw new SyntaxErrorException("Problem with configuring the parser");
    } catch(SAXException e) {
      log
          .warning("The XML file "
              + CONFIG_LOCATION
              + " could not be parsed. Most likely it has syntax errors in it. It also might use characters that are not part of the specified content encoding.");
      throw new SyntaxErrorException("Problem while parsing the XML file");
    }
  }

  /**
   * Registers a new handler for a specific namespace. The handler's function
   * for the namespace are called once a plugin with the given namespace occurs.
   * 
   * @param handler an IPluginHandler object that performs all the tasks
   *          required
   */
  private void registerHandler(IPluginMonitor.IPluginHandler handler) {
#ifdef CFG_JAVA15
    List_IPluginMonitorIPluginHandler_ handlerlist = handlers.get(handler.getNamespaceURI());
#else
    List_IPluginMonitorIPluginHandler_ handlerlist = (List_IPluginMonitorIPluginHandler_)handlers.get(handler.getNamespaceURI());
#endif
    if(handlerlist == null)
      handlers.put(handler.getNamespaceURI(), handlerlist = new ArrayList_IPluginMonitorIPluginHandler_());
    handlerlist.add(handler);
  }

  /**
   * Unregisters a handler for a specific namespace. The handler's function for
   * the namespace are called once a plugin with the given namespace occurs.
   * 
   * @param handler an IPluginHandler object that performs all the tasks
   *          required
   * @param notifyUnload if the handler's pluginUnRegistered method should be
   *          invoked
   */
  private void unregisterHandler(IPluginMonitor.IPluginHandler handler, boolean notifyUnload) {
#ifdef CFG_JAVA15
    List_IPluginMonitorIPluginHandler_ handlerlist = handlers.get(handler.getNamespaceURI());
#else
    List_IPluginMonitorIPluginHandler_ handlerlist = (List_IPluginMonitorIPluginHandler_)handlers.get(handler.getNamespaceURI());
#endif

    if(handlerlist == null)
      return;
    
    if(handlerlist.remove(handler) && notifyUnload)
      // notify the handle if it is necessary
#ifdef CFG_JAVA15
      for(Document d: loadedPlugins.values()) {
#else
      for(Iterator i = loadedPlugins.values().iterator(); i.hasNext(); ) {
        Document d = (Document)i.next();
#endif
        for(Node child = d.getDocumentElement().getFirstChild(); child != null; child = child.getNextSibling())
          if(child.getNodeType() == Node.ELEMENT_NODE && handler.getNamespaceURI().equals(child.getNamespaceURI()))
            handler.pluginUnRegistered(handler.getNamespaceURI(), child);
      }
  }
}