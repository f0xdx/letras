/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 */

package org.mundo.service.dver;

#define LOG_MODULE

#ifndef CFG_CLDC
import java.util.HashSet;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
#else
import java.util.Hashtable;
import java.util.Vector;
import org.mundo.rt.Iterator;
#endif

import java.util.Enumeration;
import org.mundo.rt.Service;
import org.mundo.rt.GUID;
import org.mundo.rt.Signal;
import org.mundo.rt.Message;
import org.mundo.rt.MessageContext;
import org.mundo.rt.Publisher;
import org.mundo.rt.Subscriber;
import org.mundo.rt.IBCLProvider;
import org.mundo.rt.TypedArray;
import org.mundo.rt.TypedMap;
import org.mundo.rt.Mundo;
import org.mundo.rt.IReceiver;
import org.mundo.rt.IMessageHandler;
import org.mundo.rt.Channel;
import org.mundo.rt.ProtocolStack;
import org.mundo.net.ProtocolCoordinator;
import org.mundo.net.routing.IRoutingService;
import org.mundo.net.transport.ITransportService;
#ifdef LOG_MODULE
import org.mundo.rt.Logger;
#  define LOG log
#else
#  define LOG //
#endif

/**
 * Client-side service of the DVER event broker.
 */
public class EventRouterClient extends Service
       implements IBCLProvider.ISignal, IMessageHandler
       emits IMessageHandler
{
  public EventRouterClient()
  {
  }
  /**
   * Initializes the service.
   */
  public void init()
  {
    super.init();

    // register mimeType to receive control messages
    ProtocolCoordinator.register(mimeType, this);

    // start worker thread
    worker = new Worker();
    worker.start();
  }
  /**
   * Terminates the service.
   */
  public void shutdown()
  {
    worker.interrupt();
  
    super.shutdown();
  }
  /**
   * Raised on a local subscribe.
   */
  public synchronized void subscriberAdded(Subscriber s) /* IBCLProvider.ISignal */
  {
    if (!checkZone(s.getChannel().getZone()))
      return;
    LOG.fine("local subscribe: "+s.toString());

#ifndef CFG_CLDC
    if (subscriberSet.contains(s))
#else
    if (subscriberSet.containsKey(s))
#endif
    {
      LOG.severe("subscriber added twice: "+s.toString());
      return;
    }
#ifndef CFG_CLDC
    subscriberSet.add(s);
#else
    subscriberSet.put(s, s);
#endif

    String channelName = s.getChannel().getName();
    SubEntry se = (SubEntry)subMap.get(channelName);
    if (se==null)
    {
      se = new SubEntry(channelName);
      se.addRef();
      se.state=true;
      subMap.put(channelName, se);
    }
    else
    {
      synchronized(se)
      {
        se.addRef();
      }
    }
    subscribersUpdated=true;
  }
  /**
   * Raised on a local unsubscribe.
   */
  public synchronized void subscriberRemoved(Subscriber s) /* IBCLProvider.ISignal */
  {
    if (!checkZone(s.getChannel().getZone()))
      return;
    LOG.fine("local unsubscribe: "+s.toString());

#ifndef CFG_CLDC
    if (!subscriberSet.remove(s))
#else
    if (subscriberSet.remove(s) == null)
#endif
    {
      LOG.severe("unknown subscriber: "+s.toString());
      return;
    }
    
    SubEntry se = (SubEntry)subMap.get(s.getChannel().getName());
    if (se==null)
      throw new IllegalStateException("reference counting is broken");
    synchronized(se)
    {
      if (!se.remRef())
      {
        se.state=false;
        subscribersUpdated=true;
      }
    }
  }
  /**
   * Raised on a local advertise.
   */
  public void publisherAdded(Publisher p) /* IBCLProvider.ISignal */
  {
    if (!checkZone(p.getChannel().getZone()))
      return;
    LOG.fine("local advertise: "+p.toString());
    
#ifndef CFG_CLDC
    if (publisherSet.contains(p))
#else
    if (publisherSet.containsKey(p))
#endif
    {
      LOG.severe("publisher added twice: "+p.toString());
      return;
    }
#ifndef CFG_CLDC
    publisherSet.add(p);
#else
    publisherSet.put(p, p);
#endif
    
    String channelName=p.getChannel().getName();
    PubEntry pe = (PubEntry)pubMap.get(channelName);
    if (pe==null)
    {
      pe=new PubEntry(channelName);
      pe.addRef();
      pe.state=true;
      pubMap.put(channelName, pe);
    }
    else
    {
      synchronized(pe)
      {
        pe.addRef();
      }
    }
    publishersUpdated=true;
    if (!quenchingEnabled && !localSubs.containsKey(channelName))
    {
      LOG.fine("auto enable "+channelName);
      localSubs.put(channelName, session.subscribe(RT_ZONE, channelName, intMsgHandler));
    }
  }
  /**
   * Raised on a local unadvertise.
   */
  public void publisherRemoved(Publisher p) /* IBCLProvider.ISignal */
  {
    if (!checkZone(p.getChannel().getZone()))
      return;
    LOG.fine("local unadvertise: "+p.toString());
    
#ifndef CFG_CLDC
    if (!publisherSet.remove(p))
#else
    if (publisherSet.remove(p) == null)
#endif
    {
      LOG.severe("unknown publisher: "+p.toString());
      return;
    }
    
    String channelName=p.getChannel().getName();
    PubEntry pe = (PubEntry)pubMap.get(channelName);
    if (pe==null)
      throw new IllegalStateException("reference counting is broken");
    synchronized(pe)
    {
      if (!pe.remRef())
      {
        pe.state=false;
        publishersUpdated=true;

        if (!quenchingEnabled)
        {
          Subscriber sub = (Subscriber)localSubs.remove(channelName);
          if (sub!=null)
          {
            LOG.fine("auto disable "+channelName);
            session.unsubscribeDelayed(sub);
          }
        }
      }
    }
  }
  /**
   *
   */
  public boolean down(Message msg) // IMessageHandler
  {
#ifdef CFG_CHECKED_BUILD
    String channelName;
    try
    {
      channelName=msg.getMap(CHUNK_NAME, "passive").getString("channel");
    }
    catch(NullPointerException x)
    {
      LOG.severe("missing channel name parameter in down");
      return false;
    }
    LOG.finer("forwarding msg for "+channelName+" to server");
#endif
    sendToServer(msg);
    return true;
  }
  /**
   * Raised when an external message has been received.
   */
  public boolean up(Message msg) // IMessageHandler
  {
    TypedMap map=msg.getMap(CHUNK_NAME, "passive");
    if (map==null)
      return false;
    String request=map.getString("request", null);
    if (request==null)
      return false;
    if (request.equals("ServerAd"))
      handleServerAd(map.getGUID("server"));
    else if (request.equals("Enable"))
    {
      if (quenchingEnabled)
        handleEnable(map);
    }
    else if (request.equals("Message"))
      handleServerMessage(map, msg);
    return true;
  }
  /**
   *
   */
  private synchronized void handleServerAd(GUID id)
  {
    if (id.equals(serverId))
    {
      LOG.warning("received another server ad with same id: "+id.toString());
      return;
    }
    serverId=id;
    LOG.fine("server found: "+serverId.shortString());
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
    for (SubEntry se : subMap.values())
    {
#else
    for (Iterator iter = subMap.values().iterator(); iter.hasNext();)
    {
      SubEntry se = (SubEntry)iter.next();
#endif
#else
    for (Enumeration e = subMap.elements(); e.hasMoreElements();)
    {
      SubEntry se = (SubEntry)e.nextElement();
#endif
      synchronized(se)
      {
        se.committedState=false;
      }
    }
    subscribersUpdated=true;
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
    for (PubEntry pe : pubMap.values())
    {
#else
    for (Iterator iter = pubMap.values().iterator(); iter.hasNext();)
    {
      PubEntry pe = (PubEntry)iter.next();
#endif
#else
    for (Enumeration e = pubMap.elements(); e.hasMoreElements();)
    {
      PubEntry pe = (PubEntry)e.nextElement();
#endif
      synchronized(pe)
      {
        pe.committedState=false;
      }
    }
    publishersUpdated=true;
    if (quenchingEnabled)
    {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
      enabledChannels=new HashSet<String>();
      for (Subscriber sub : localSubs.values())
        session.unsubscribe(sub);
      localSubs=new HashMap<String,Subscriber>();
#else
      enabledChannels = new HashSet();
      for (Iterator iter = localSubs.values().iterator(); iter.hasNext();)
        session.unsubscribe((Subscriber)iter.next());
      localSubs = new HashMap();
#endif
#else
      enabledChannels = new Hashtable();
      for (Enumeration e = localSubs.elements(); e.hasMoreElements();)
        session.unsubscribe((Subscriber)e.nextElement());
      localSubs = new Hashtable();
#endif
    }
    if (messageQueue!=null)
    {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
      for (Message msg : messageQueue)
      {
#else
      for (Iterator iter = messageQueue.iterator(); iter.hasNext();)
      {
        Message msg = (Message)iter.next();
#endif
#else
      for (Enumeration e = messageQueue.elements(); e.hasMoreElements();)
      {
        Message msg = (Message)e.nextElement();
#endif
        Message dmsg = msg.copyFrame();
        TypedMap amap = new TypedMap();
        amap.put("destType", "node");
        amap.put("destId", serverId);
        dmsg.put("rs", "param", amap);
        if (!emit.down(dmsg))
        {
          LOG.warning("send failed > "+serverId.shortString());
        }
      }
      messageQueue=null;
    }
  }
  /**
   *
   */
  private synchronized void handleEnable(TypedMap map)
  {
    TypedArray enables = map.getArray("enables", null);
    if (enables!=null)
    {
#ifdef CFG_JAVA15
      for (Object obj : enables)
      {
        TypedMap m = (TypedMap)obj;
#else
      for (Iterator iter = enables.iterator(); iter.hasNext();)
      {
        TypedMap m = (TypedMap)iter.next();
#endif
        String channelName = m.getString("channel");
#ifndef CFG_CLDC
        if (!enabledChannels.add(channelName))
#else
        if (enabledChannels.put(channelName, channelName) != null)
#endif
        {
          LOG.warning("duplicate enable for "+channelName);
        }
        else
        {
          LOG.fine("enable "+channelName);
          localSubs.put(channelName, session.subscribe(RT_ZONE, channelName, intMsgHandler));
        }
      }
    }
    TypedArray disables = map.getArray("disables", null);
    if (disables!=null)
    {
#ifdef CFG_JAVA15
      for (Object obj : disables)
      {
        TypedMap m = (TypedMap)obj;
#else
      for (Iterator iter = disables.iterator(); iter.hasNext();)
      {
        TypedMap m = (TypedMap)iter.next();
#endif
        String channelName = m.getString("channel");
#ifndef CFG_CLDC
        if (!enabledChannels.remove(channelName))
#else
        if (enabledChannels.remove(channelName) == null)
#endif
        {
          LOG.warning("duplicate disable for "+channelName);
        }
        else
        {
          LOG.fine("disable "+channelName);
          session.unsubscribe((Subscriber)localSubs.remove(channelName));
        }
      }
    }
  }
  /**
   *
   */
  private void handleServerMessage(TypedMap map, Message msg)
  {
    LOG.finer("received message for "+map.getString("channel"));
/*
    try
    {
      msg.activate();
    }
    catch(Throwable t)
    {
      LOG.exception(t);
    }
*/
    Mundo.bcl.send(new Channel("rt", map.getString("channel")), msg, session);
  }
  /**
   * Checks whether we are responsible for the specified zone.
   */
  private boolean checkZone(String zoneName)
  {
    return "lan".equals(zoneName);
  }
  /**
   * Sends a control message to the server.
   */
  private void sendToServer(TypedMap map)
  {
    if (serverId==null)
      throw new IllegalStateException("no server");
    Message msg = new Message();
    msg.put(CHUNK_NAME, "passive", map);

    TypedMap amap = new TypedMap();
    amap.put("destType", "node");
    amap.put("destId", serverId);
    msg.put("rs", "param", amap);

    msg.setStack(ProtocolCoordinator.getInstance().getDefaultStack(), IBCLProvider.ISignal.class);
    msg.setType(mimeType);
    if (!emit.down(msg))
    {
      LOG.warning("send failed > "+serverId.shortString());
    }
  }
  /**
   * Sends a payload message to the server.
   */
  private void sendToServer(Message msg)
  {
    if (serverId==null)
    {
      LOG.finer("no server - enqueuing msg");
      synchronized(this)
      {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
        if (messageQueue==null)
          messageQueue = new ArrayList<Message>();
        messageQueue.add(msg);
#else
        if (messageQueue==null)
          messageQueue = new ArrayList();
        messageQueue.add(msg);
#endif
#else
        if (messageQueue==null)
          messageQueue = new Vector();
        messageQueue.addElement(msg);
#endif
      }
      return;
    }
    LOG.finer("sending msg to server");
    Message dmsg = msg.copyFrame();
    TypedMap amap = new TypedMap();
    amap.put("destType", "node");
    amap.put("destId", serverId);
    dmsg.put("rs", "param", amap);
    if (!emit.down(dmsg))
    {
      LOG.warning("send failed > "+serverId.shortString());
    }
  }

  private class Entry
  {
    void addRef()
    {
      refcnt++;
    }
    boolean remRef()
    {
      if (refcnt==0)
        throw new IllegalStateException("reference counter underrun");
      refcnt--;
      return refcnt>0;
    }
    public String toString()
    {
      return channelName;
    }
    String channelName;
    int refcnt=0;
    boolean state=false;
    boolean committedState=false;
  }

  private class SubEntry extends Entry
  {
    SubEntry(String channelName)
    {
      this.channelName=channelName;
    }
  }
  
  private class PubEntry extends Entry
  {
    PubEntry(String channelName)
    {
      this.channelName=channelName;
    }
  }

  private class Worker extends Thread
  {
    Worker()
    {
    }
    public void run()
    {
      try
      {
        for(;;)
        {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
          ArrayList<SubEntry> subs = null;
          ArrayList<PubEntry> pubs = null;
#else
          ArrayList subs = null;
          ArrayList pubs = null;
#endif
#else
          Vector subs = null;
          Vector pubs = null;
#endif
          synchronized(EventRouterClient.this)
          {
            if (serverId!=null)
            {
              if (subscribersUpdated)
              {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
                subs = new ArrayList<SubEntry>(subMap.values());
#else
                subs = new ArrayList(subMap.values());
#endif
#else
                subs = new Vector();
                for (Enumeration e = subMap.elements(); e.hasMoreElements();)
                  subs.addElement(e.nextElement());
#endif
                subscribersUpdated = false;
              }
              if (publishersUpdated)
              {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
                pubs = new ArrayList<PubEntry>(pubMap.values());
#else
                pubs = new ArrayList(pubMap.values());
#endif
#else
                pubs = new Vector();
                for (Enumeration e = pubMap.elements(); e.hasMoreElements();)
                  pubs.addElement(e.nextElement());
#endif
                publishersUpdated = false;
              }
            }
          }
          TypedArray subReqs = new TypedArray();
          TypedArray unsubReqs = new TypedArray();
          if (subs!=null)
          {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
            for (SubEntry se : subs)
            {
#else
            for (Iterator iter = subs.iterator(); iter.hasNext();)
            {
              SubEntry se = (SubEntry)iter.next();
#endif
#else
            for (Enumeration e = subs.elements(); e.hasMoreElements();)
            {
              SubEntry se = (SubEntry)e.nextElement();
#endif
              synchronized(se)
              {
                if (se.state && !se.committedState)
                {
                  LOG.fine("send subscribe "+se.toString());
                  se.committedState=se.state;
                  TypedMap map=new TypedMap();
                  map.put("channel", se.channelName);
                  subReqs.add(map);
                }
                else if (!se.state && se.committedState)
                {
                  LOG.fine("send unsubscribe "+se.toString());
                  se.committedState=se.state;
                  TypedMap map=new TypedMap();
                  map.put("channel", se.channelName);
                  unsubReqs.add(map);
                }
              }
            }
          }
          TypedArray advReqs = new TypedArray();
          TypedArray unadvReqs = new TypedArray();
          if (pubs!=null)
          {
#ifndef CFG_CLDC
#ifdef CFG_JAVA15
            for (PubEntry pe : pubs)
            {
#else
            for (Iterator iter = pubs.iterator(); iter.hasNext();)
            {
              PubEntry pe = (PubEntry)iter.next();
#endif
#else
            for (Enumeration e = pubs.elements(); e.hasMoreElements();)
            {
              PubEntry pe = (PubEntry)e.nextElement();
#endif
              synchronized(pe)
              {
                if (pe.state && !pe.committedState)
                {
                  LOG.fine("send advertise "+pe.toString());
                  pe.committedState=pe.state;
                  TypedMap map=new TypedMap();
                  map.put("channel", pe.channelName);
                  advReqs.add(map);
                }
                else if (!pe.state && pe.committedState)
                {
                  LOG.fine("send unadvertise "+pe.toString());
                  pe.committedState=pe.state;
                  TypedMap map=new TypedMap();
                  map.put("channel", pe.channelName);
                  unadvReqs.add(map);
                }
              }
            }
          }
          if (subReqs.size()>0 || unsubReqs.size()>0 ||
              advReqs.size()>0 || unadvReqs.size()>0)
          {
            TypedMap msg=new TypedMap();
            msg.put("request", "Update");
            msg.put("clientId", Mundo.getNodeId());
            if (subReqs.size()>0)
              msg.put("subscribes", subReqs);
            if (unsubReqs.size()>0)
              msg.put("unsubscribes", unsubReqs);
            if (advReqs.size()>0)
              msg.put("advertises", advReqs);
            if (unadvReqs.size()>0)
              msg.put("unadvertises", unadvReqs);
            sendToServer(msg);
          }
          // FIXME: use a monitor here
          Thread.sleep(100);
        }
      }
      catch(InterruptedException x)
      {
      }
    }
  }

  private final IReceiver intMsgHandler = new IReceiver()
  {
    public void received(Message msg, MessageContext ctx)
    {
      LOG.finer("local msg for "+ctx.channel.getName());
      boolean enabled;
      if (quenchingEnabled)
      {
        synchronized(EventRouterClient.this)
        {
#ifndef CFG_CLDC
          enabled = enabledChannels.contains(ctx.channel.getName());
#else
          enabled = enabledChannels.containsKey(ctx.channel.getName());
#endif
        }
      }
      else
        enabled=true;
      if (enabled)
      {
        msg = msg.copyFrame();

        TypedMap map = new TypedMap();
        map.put("request", "Message");
        map.put("channel", ctx.channel.getName());
        map.put("clientId", Mundo.getNodeId());
        map.put("contentType", msg.getType());
        msg.put(CHUNK_NAME, "passive", map);

        msg.setType(mimeType); 
        ProtocolCoordinator.getInstance().firstDown(msg);
      }
    }
  };

#ifndef CFG_CLDC
#ifdef CFG_JAVA15
  private HashSet<Subscriber> subscriberSet = new HashSet<Subscriber>();
  private HashSet<Publisher> publisherSet = new HashSet<Publisher>();
  private HashMap<String,SubEntry> subMap = new HashMap<String,SubEntry>();
  private HashMap<String,PubEntry> pubMap = new HashMap<String,PubEntry>();
  private HashSet<String> enabledChannels = new HashSet<String>();
  private HashMap<String,Subscriber> localSubs = new HashMap<String,Subscriber>();
  private ArrayList<Message> messageQueue = null;
#else
  private HashSet subscriberSet = new HashSet();
  private HashSet publisherSet = new HashSet();
  private HashMap subMap = new HashMap();
  private HashMap pubMap = new HashMap();
  private HashSet enabledChannels = new HashSet();
  private HashMap localSubs = new HashMap();
  private ArrayList messageQueue = null;
#endif
#else
  private Hashtable subscriberSet = new Hashtable();
  private Hashtable publisherSet = new Hashtable();
  private Hashtable subMap = new Hashtable();
  private Hashtable pubMap = new Hashtable();
  private Hashtable enabledChannels = new Hashtable();
  private Hashtable localSubs = new Hashtable();
  private Vector messageQueue = null;
#endif
  private boolean subscribersUpdated = false;
  private boolean publishersUpdated = false;
  private Logger log = Logger.getLogger("erc");
  private Worker worker;
  private GUID serverId;
  private boolean quenchingEnabled=false;
  // Event Router Client/Server Protocol
  private static final String CHUNK_NAME="ercsp";
  private static final String RT_ZONE="rt";
  private static final String mimeType = "message/mc-ercsp";
}
