/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 * Stefan Radomski
 */

package org.mundo.service;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import org.mundo.rt.IReceiver;
import org.mundo.rt.Message;
import org.mundo.rt.MessageContext;
import org.mundo.rt.Logger;
import org.mundo.rt.Session;
import org.mundo.rt.DoObject;
import org.mundo.rt.GUID;
import org.mundo.rt.Signal;
import org.mundo.rt.TypedMap;
import org.mundo.net.routing.IRoutingService;
import org.mundo.service.ServiceInfo;

#ifndef CFG_CLDC
import org.mundo.filter.IFilter;
#endif

#ifdef CFG_CHECKED_BUILD
#  define LOG log
#else
#  define LOG //
#endif

/**
 * <p>Encapsulates the result of a service query. Instances of <code>FilteredSet</code>
 * are returned by the query functions of <code>ServiceManager</code>
 * and are usually not instantiated directly from client code.</p>
 *
 * <p><b>Loggers:</b> svcrs</p>
 *
 * @see ServiceManager
 * @author Erwin Aitenbichler
 */
public class FilteredSet implements Iterable<ServiceInfo>, IReceiver, IRoutingService.IConn emits FilteredSet.ISignal
{
  /**
   * Initializes a new result set.
   */
  public FilteredSet(Session s)
  {
    session = s;
    // monitor coming and leaving peers
    Signal.connect("rt", IRoutingService.IConn.class, this);
  }
  /**
   * Stops updating of the result set.
   */
  public void release()
  {
    Signal.disconnect(IRoutingService.IConn.class, this);
    // TODO: disconnectAllReceivers
    // TODO: unsubscribe
  }
  /**
   * Returns all elements of the result set.
   */
  public List getList()
  {
    return list;
  }
  /**
   * Returns an iterator for the ServiceInfo elements contained in this result set.
   */
  public Iterator<ServiceInfo> iterator()
  {
    return list.iterator();
  }
  /**
   * Returns a string representation of this result set.
   */
  public String toString()
  {
    return list.toString();
  }
#ifndef CFG_CLDC
  /**
   * Internal use only. Sets the filter associated with this result set.
   */
  public void setFilter(IFilter f)
  {
    filter = f;
  }
  /**
   * Internal use only. Gets the filter associated with this result set.
   */
  public IFilter getFilter()
  {
    return filter;
  }
#endif
  
  public synchronized void received(Message msg, MessageContext ctx) // IReceiver
  {
    try
    {
      ServiceInfo si = (ServiceInfo)msg.getObject();

      // find the received ServiceInfo in the list
      int n = -1;
      int s = list.size();
      for (int i=0; i<s; i++)
      {
        if (list.get(i).guid.equals(si.guid))
        {
          n = i;
          break;
        }
      }

      // Remote object references received through normal messages are
      // unbound. For that reason, we must bind references to the target
      // session before we can use them.
      if (session!=null && si.doService!=null)
      {
        // create a copy of ServiceInfo before modifying it, because it
        // might be used by others as well
        si = new ServiceInfo(si);
        // create a copy of the remote reference to the service
        si.doService = (DoObject)si.doService.clone();
        // bind the remote reference to the receiver's session
        si.doService._bind(session);
        
        if (si.update == si.UPDATE_PROPCHANGED)
        {
          // If a property change caused this element to become visible in this
          // result set, then change the update type to advertise.
          if (n < 0)
            si.update = si.UPDATE_ADVERTISE;
        }
        else if (si.update == si.UPDATE_PROPCHANGING)
        {
          // If a property change causes this element to become invisible in this
          // result set, then change the update type to unadvertise.
//          TypedMap map = msg.getMap("main", "passive").getMap("newObject");
//          if (map!=null && filter!=null && !filter.matches(map))
//            si.update = si.UPDATE_UNADVERTISE;
          if (filter!=null && !filter.matches(si))
            si.update = si.UPDATE_UNADVERTISE;

        }
      }

      switch (si.update)
      {
        case ServiceInfo.UPDATE_ADVERTISE:
          if (n>=0)
            break;
          LOG.finer("service + "+si);
          list.add(si);
          LOG.finest("inserted: offset="+s+", n=1");
          emit.inserted(this, s, 1);
          break;
        case ServiceInfo.UPDATE_UNADVERTISE:
          if (n<0)
            break;
          LOG.finer("service - "+list.get(n));
          LOG.finest("removing: offset="+n+", n=1");
          emit.removing(this, n, 1);
          list.remove(n);
          LOG.finest("removed: offset="+n+", n=1");
          emit.removed(this, n, 1);
          break;
        case ServiceInfo.UPDATE_PROPCHANGING:
          if (n<0)
            break;
          LOG.finer("service propChanging "+si);
          LOG.finest("propChanging: offset="+n);
          emit.propChanging(this, n);
          break;
        case ServiceInfo.UPDATE_PROPCHANGED:
          if (n<0)
            break;
          list.set(n, si);
          LOG.finer("service propChanged "+si);
          LOG.finest("propChanged: offset="+n);
          emit.propChanged(this, n);
          break;
      }
    }
    catch(Exception x)
    {
      log.exception(x);
    }
  }

  /**
   * Raised when a new node is available.
   * @param id  the GUID of the new node.
   */
  public void nodeAdded(GUID id) // IRoutingService.IConn
  {
  }

  /**
   * Raised when no routes are left to a node.
   * @param id  the GUID of the node lost.
   */
  public synchronized void nodeRemoved(GUID id) // IRoutingService.IConn
  {
    LOG.fine("node - "+id.shortString());
    int n = 0;
    int first = -1;
    for (int i=0; i<list.size(); i++)
    {
      ServiceInfo si = list.get(i);
      if (id.equals(si.nodeId))
      {
        LOG.finest("service - "+si);
        if (first<0)
        {
          first = i;
          n = 1;
        }
        else
          n++;
      }
      else if (first>=0)
      {
        LOG.finest("removing: first="+first+", n="+n);
        emit.removing(this, first, n);
        for (int j=0; j<n; j++)
          list.remove(first);
        LOG.finest("removed: first="+first+", n="+n);
        emit.removed(this, first, n);
        first = -1;
        i -= n;
        n = 0;
      }
    }
    if (first>=0)
    {
      LOG.finest("removing: first="+first+", n="+n);
      emit.removing(this, first, n);
      for (int j=0; j<n; j++)
        list.remove(first);
      LOG.finest("removed: first="+first+", n="+n);
      emit.removed(this, first, n);
    }
  }

  /**
   * Interface defining the events raised by a result set.
   * @author Erwin Aitenbichler
   */
  public interface ISignal
  {
    /**
     * Raised after one or more elements were inserted into the result set.
     * @param offset  index of first new element
     * @param n       number of new elements
     */
    void inserted(FilteredSet rs, int offset, int n);
    /**
     * Raised before one or more elements are removed from the result set.
     * @param offset  index of first element that will be removed
     * @param n       number of elements that will be removed
     */
    void removing(FilteredSet rs, int offset, int n);
    /**
     * Raised after one or more elements were removed from the result set.
     * @param offset  index of first element removed
     * @param n       number of elements removed
     */
    void removed(FilteredSet rs, int offset, int n);
    /**
     * Raised before the properties of an element are changed.
     * @param offset  index of the element that will be changed
     */
    void propChanging(FilteredSet rs, int offset);
    /**
     * Raised after the properties of an element were changed.
     * @param offset  index of the element changed.
     */
    void propChanged(FilteredSet rs, int offset);
  }
  
  /**
   * An abstract adapter class for receiving events from the signal interface.
   * The methods in this class are empty. This class exists as convenience
   * for creating receiver objects.
   * @author Erwin Aitenbichler
   */
  public static class SignalAdapter implements ISignal
  {
    public void inserted(FilteredSet rs, int offset, int n) {}
    public void removing(FilteredSet rs, int offset, int n) {}
    public void removed(FilteredSet rs, int offset, int n) {}
    public void propChanging(FilteredSet rs, int offset) {}
    public void propChanged(FilteredSet rs, int offset) {}
  }

  private Session session;
#ifndef CFG_CLDC
  private IFilter filter;
#endif
  private ArrayList<ServiceInfo> list = new ArrayList<ServiceInfo>();
  private Logger log = Logger.getLogger("svcrs");
}
