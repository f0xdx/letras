/*
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is MundoCore Java.
 *
 * The Initial Developer of the Original Code is Telecooperation Group,
 * Department of Computer Science, Darmstadt University of Technology.
 * Portions created by the Initial Developer are
 * Copyright (C) 2001-2008 the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Erwin Aitenbichler
 * Stefan Radomski
 * Niklas Lochschmidt
 */

package org.mundo.service;

#ifndef CFG_J2ME
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import java.util.jar.JarFile;
import java.util.jar.JarEntry;
import org.mundo.annotation.*;
import org.mundo.util.plugins.PluginManager;
import org.mundo.util.plugins.IPluginMonitor;
import org.w3c.dom.Node;
import org.mundo.xml.XMLDeserializer;
import java.net.InetAddress;
#else
import java.util.Enumeration;
#ifdef CFG_CLDC
import org.mundo.rt.Iterator;
#else
import java.util.Iterator;
#endif
#endif
#ifdef CFG_JAVA15
import java.util.concurrent.CopyOnWriteArrayList;
#endif

import org.mundo.rt.Metaclass;
import org.mundo.rt.GUID;
import org.mundo.rt.ActiveMap;
import org.mundo.rt.TypedMap;
import org.mundo.rt.TypedArray;
import org.mundo.rt.Service;
import org.mundo.rt.Session;
import org.mundo.rt.Mundo;
import org.mundo.rt.Signal;
import org.mundo.rt.Logger;
import org.mundo.rt.IActivate;
import org.mundo.rt.TypedContainer;
import org.mundo.rt.Blob;
import org.mundo.rt.DoObject;
import org.mundo.rt.AsyncCall;
import org.mundo.rt.Subscriber;
import org.mundo.rt.Publisher;
import org.mundo.rt.Message;
import org.mundo.rt.RootService;
#ifndef CFG_CLDC
import org.mundo.net.broker.ContentSubscription;
import org.mundo.filter.TypedMapFilter;
#endif

#ifdef CFG_CHECKED_BUILD
#  define LOG log
#else
#  define LOG //
#endif

/**
 * <p>The service manager keeps track of local and remote services.</p>
 *
 * <p><b>Loggers:</b> svcman</p>
 */
public class ServiceManager extends RootService implements IServiceManager, Service.IProp
#ifndef CFG_J2ME
	, IPluginMonitor.IPluginHandler
#endif
{
  /**
   * Options to configure ServiceManager
   */
  @mcSerialize(className="ServiceManager$Options")
  public static class OptServiceManager implements IActivate
  {
    /**
     * The path specifying the location of the plugins directory.
     */
    @mcField(name="plugin-directory", optional=true)
    public String pluginDirectory;
    /**
     * Connect service manager to the specified channel.
     */
    @mcField(optional=true)
    public String channel;
    /**
     * A list of service instances to create.
     */
    @mcField(name="instances")
    public TypedArray instances;
  }

  /**
   * Configuration options to register a new service class.
   */
  @mcSerialize(className="ServiceManager$OptRegisterClass")
  public static class OptRegisterClass implements IActivate
  {
    public String name;
  }

  /**
   * Configuration options to create a new service instance.
   */
  @mcSerialize(className="ServiceManager$OptNewInstance")
  public static class OptNewInstance implements IActivate
  {
    public String name;
    public String classname;
    @mcField(optional=true)
    public Object config;
  }

  /**
   * Initializes a new service manager.
   */
  public ServiceManager()
  {
  }
  /**
   * Returns the singleton instance of <code>ServiceManager</code>.
   */
  public static ServiceManager getInstance()
  {
    return singleton;
  }
  /**
   * Initializes the service. The service interface is connected to a channel
   * with the name <code>nodeId + ".ServiceManager"</code>, where <code>nodeId</code>
   * is the string representation of this node's GUID.
   */
  @Override
  public void init()
  {
    setState(STATE_INITIALIZING);
#ifdef CFG_CHECKED_BUILD
    long startTime = System.currentTimeMillis();
#endif
    singleton = this;
    conf = (OptServiceManager)Mundo.getConfig().getObject("ServiceManager", null);
    if (conf == null)
    {
      LOG.finest("no configuration found");
      conf = new OptServiceManager();
    }

#ifndef CFG_J2ME
#ifdef CFG_JAVA15
    services = new CopyOnWriteArrayList<Service>();
    for (Service svc : Mundo.getServices())
    {
#else
    services = new ArrayList();
    for (Iterator iter = Mundo.getServices().iterator(); iter.hasNext();)
    {
      Service svc = (Service)iter.next();
#endif
#else
    services = new TypedArray();
    for (Enumeration e = Mundo.getServices().elements(); e.hasMoreElements();)
    {
      Service svc = (Service)e.nextElement();
#endif
      if (svc.getServiceInstanceName()==null)
        assignInstanceName(svc);
      services.add(svc);
    }


#ifdef CFG_ANDROID
  String hostName="android";
#else
    String hostName="localhost";
#ifndef CFG_J2ME
    try
    {
      // Use getByName(), because getLocalHost() can be awfully slow.
      // (In several tests it took >15 seconds.)
      // hostName = InetAddress.getLocalHost().getHostName();
      hostName = InetAddress.getByName("127.0.0.1").getHostName();

      hostName = hostName.toLowerCase();
      int i = hostName.indexOf('.');
      if (i>0)
        hostName = hostName.substring(0, i);
      LOG.fine("hostName: "+hostName);
    }
    catch(Exception x)
    {
      log.exception(x);
    }
#endif
#endif


#ifdef CFG_CHECKED_BUILD
    log.finer("startup took "+(System.currentTimeMillis()-startTime)+" ms");
#endif
    // Create instances defined in configuration file
    if (conf.instances!=null)
    {
      LOG.finest(conf.instances.size()+" instances");
      for (Iterator iter=conf.instances.iterator(); iter.hasNext();)
      {
        TypedMap map=(TypedMap)iter.next();
        String className=map.getString("classname", null);
        if (className==null)
          continue;
        String name=map.getString("name", null);
        LOG.fine("new-instance: name="+name);
        try
        {
          Service svc=(Service)Class.forName(className).newInstance();
          if (name!=null)
            svc.setServiceInstanceName(name);
          String zone=map.getString("zone", null);
          if (zone!=null)
            svc.setServiceZone(zone);

          Object cfg=map.get("config."+hostName);
          if (cfg!=null)
          {
            LOG.fine("new-instance: using config for "+hostName);
          }
          else
            cfg=map.get("config");
          if (cfg!=null)
            svc.setServiceConfig(cfg);
#ifdef CFG_CHECKED_BUILD
          long t = System.currentTimeMillis();
          Mundo.registerService(svc);
          LOG.finer("init of service "+svc.getServiceInstanceName()+" took "+(System.currentTimeMillis()-t)+" ms");
#else
          Mundo.registerService(svc);
#endif
        }
        catch(Exception x)
        {
          log.exception(x);
        }
      }
    }
    else
    {
      LOG.finest("no instances");
    }

#ifndef CFG_J2ME
    // Load plug-ins
    if (conf.pluginDirectory!=null)
    {
      try
      {
        File dir = new File(conf.pluginDirectory);
        File[] files = dir.listFiles();
        if (files!=null)
        {
          for (File file : files)
          {
            if (file.getName().startsWith("tmp-"))
            {
              LOG.fine("delete " + file.getName());
              file.delete();
            }
          }
        }
      }
      catch(Exception x)
      {
        log.exception(x);
      }
      try
      {
        LOG.fine("using plugin directory '"+conf.pluginDirectory+"'");
        PluginManager.addPluginHandler(this, new File(conf.pluginDirectory));
      }
      catch(Exception x)
      {
        log.exception(x);
      }
    }
#endif

    Signal.connect(getSession().subscribe("lan", Mundo.getNodeId()+".ServiceManager"), this);
    if (conf.channel!=null)
    {
      String channel=conf.channel;
      int i=channel.indexOf("$hostname");
      if (i>=0)
        channel=channel.substring(0, i)+hostName+channel.substring(i+9);
      Signal.connect(getSession().subscribe("lan", channel), this);
    }

    Signal.connect(getSession().subscribe("lan", "lan.sd"), this);
#ifdef CFG_JAVA15
    Signal.connect("rt", Service.IProp.class, this);
#endif
    setState(STATE_INITIALIZED);
  }

  private Service getServiceById(GUID id)
  {
    synchronized(services)
    {
#ifdef CFG_JAVA15
      for (Service s : services)
      {
#else
      for (Iterator iter = services.iterator(); iter.hasNext();)
      {
        Service s = (Service)iter.next();
#endif
        if (s.getServiceId().equals(id))
          return s;
      }
    }
    return null;
  }

  /**
  * Get a service by friendly name. This method only finds local instances. To discover a service on the network,
  * a service discovry with <code>query</code> or <code>contQuery</code> needs to be performed.
  */
  public Service getServiceByName(String name)
  {
    synchronized(services)
    {
#ifdef CFG_JAVA15
      for (Service s : services)
      {
#else
      for (Iterator iter = services.iterator(); iter.hasNext();)
      {
        Service s = (Service)iter.next();
#endif
        if (s.getServiceInstanceName().equals(name))
          return s;
      }
    }
    return null;
  }


  /**
  * Get a service by interface. This method only finds local instances. To discover a service on the network,
  * a service discovry with <code>query</code> or <code>contQuery</code> needs to be performed. If multiple
  * services implement the interface, only the first found service is returned.
  */
  public Service getServiceByInterface(Class iface)
  {
	 if (!iface.isInterface()) {
		 return null;
	 }
    synchronized(services)
    {
#ifdef CFG_JAVA15
      for (Service s : services)
      {
#else
      for (Iterator iter = services.iterator(); iter.hasNext();)
      {
        Service s = (Service)iter.next();
#endif
    	  if (iface.isAssignableFrom(s.getClass())) {
    		  return s;
    	  }
      }
    }
    return null;
  }

  /**
   * For internal use only. Called by <code>Mundo.registerService</code> to update
   * the services list.
   */
  @Override
  public void serviceRegistered(Service svc)
  {
    synchronized(services)
    {
      services.add(svc);
    }
    if (svc.getServiceInstanceName()==null)
      assignInstanceName(svc);
#ifdef CFG_JAVA15
    advertiseService(svc, ServiceInfo.UPDATE_ADVERTISE);
#endif
  }
  /**
   * For internal use only. Called by <code>Mundo.unregisterService</code> to update
   * the services list.
   */
  @Override
  public void serviceUnregistered(Service svc)
  {
    synchronized(services)
    {
      services.remove(svc);
    }
#ifndef CFG_J2ME
    Plugin plugin=null;
    synchronized(service2plugin)
    {
      plugin = (Plugin)service2plugin.get(svc);
    }
    if (plugin!=null)
      plugin.removeInstance(svc);
#endif
#ifdef CFG_JAVA15
    advertiseService(svc, ServiceInfo.UPDATE_UNADVERTISE);
#endif
  }
  /**
   * Automatically assigns an instance name to the specified service.
   */
  private void assignInstanceName(Service unnamed)
  {
    Class unnamedClass=unnamed.getClass();
    int i, j, max=0;
    String s;
    synchronized(services)
    {
#ifdef CFG_JAVA15
      for (Service svc : services)
      {
#else
      for (Iterator iter = services.iterator(); iter.hasNext();)
      {
        Service svc = (Service)iter.next();
#endif
        if (unnamedClass==svc.getClass())
        {
          s=svc.getServiceInstanceName();
          if (s!=null)
          {
            i=s.lastIndexOf('(');
            j=s.lastIndexOf(')');
            if (i>0 && j>i)
            {
              i=Integer.parseInt(s.substring(i+1, j));
              if (i>max)
                max=i;
            }
          }
        }
      }
    }
    s=unnamedClass.getName();
    i=s.lastIndexOf('.');
    if (i>0)
      s=s.substring(i+1);
    unnamed.setServiceInstanceName(s+" ("+(max+1)+")");
  }

#ifndef CFG_J2ME
  /**
   * Returns a list of services hosted in this node.
   * @return  a <code>List</code> of <code>ServiceEntry</code> objects.
   * @see IServiceManager
   */
  public List getServiceInstances() // IServiceManager
  {
#ifdef CFG_JAVA15
    ArrayList<ServiceInfo> list = new ArrayList<ServiceInfo>();
#else
    ArrayList list = new ArrayList();
#endif
    synchronized(services)
    {
#ifdef CFG_JAVA15
      for (Service s : services)
      {
#else
      for (Iterator iter = services.iterator(); iter.hasNext();)
      {
        Service s = (Service)iter.next();
#endif
        ServiceInfo si = getServiceInfo(s);

        synchronized(service2plugin)
        {
          Plugin p = (Plugin)service2plugin.get(s);
          if (p!=null)
            si.pluginName=p.pluginName;
        }
        list.add(si);
      }
    }
    return list;
  }
  /**
   * Returns the list of service classes available.
   *
   * @see IServiceManager
   */
  public List getServiceClasses() // IServiceManager
  {
#ifdef CFG_JAVA15
    ArrayList<ServiceClass> list = new ArrayList<ServiceClass>();
#else
    ArrayList list = new ArrayList();
#endif
    synchronized(plugins)
    {
#ifdef CFG_JAVA15
      for (Map.Entry<String,Plugin> e : plugins.entrySet())
      {
#else
      for (Iterator iter = plugins.entrySet().iterator(); iter.hasNext();)
      {
        Map.Entry e = (Map.Entry)iter.next();
#endif
        ServiceClass sc = new ServiceClass();
        sc.className = (String)e.getKey();
        sc.pluginName = ((Plugin)e.getValue()).pluginName;
        list.add(sc);
      }
    }
    return list;
  }

  /**
   * Returns the configuration of the specified service.
   * @param id  the GUID of the service.
   * @return  a map containing the service configuration as a passive object tree; or
   *          <code>null</code> if the specified service GUID is invalid.
   * @see  IServiceManager
   */
  public TypedMap getServiceConfig(GUID id) // IServiceManager
  {
    Service service=getServiceById(id);
    if (service==null)
      return null;
    try
    {
      return service.getServiceConfigMap();
    }
    catch(Exception x)
    {
      log.exception(x);
    }
    return null;
  }
  /**
   * Sets the configuration for the specified service.
   * @param id  the GUID of the service.
   * @param cfg  a map containing the service configuration as a passive object tree.
   * @see  IServiceManager
   */
  public void setServiceConfig(GUID id, TypedMap cfg) // IServiceManager
  {
    Service service=getServiceById(id);
    if (service==null)
      return;
    try
    {
      service.setServiceConfigMap(cfg);
    }
    catch(Exception x)
    {
      log.exception(x);
    }
  }
  /**
   * Shutdown the specified service.
   * @param id  the GUID of the service.
   * @see  IServiceManager
   */
  public void shutdownService(GUID id) // IServiceManager
  {
    Service service=getServiceById(id);
    if (service==null)
      throw new IllegalArgumentException("no service with that id");
    Mundo.unregisterService(service);
  }
  /**
   * Shutdown the specified service.
   * @param name  the instance name of the service.
   * @see  IServiceManager
   */
  public void shutdownService(String name) // IServiceManager
  {
    Service service=getServiceByName(name);
    if (service==null)
      throw new IllegalArgumentException("no service with that name");
    Mundo.unregisterService(service);
  }
  /**
   * Creates a new service instance.
   * @see  IServiceManager
   */
  public DoObject newInstance(String className, String instanceName, TypedMap cfg)
         throws ClassNotFoundException, InstantiationException, IllegalAccessException
  {
    Plugin plugin = (Plugin)plugins.get(className);
    if (plugin==null)
      throw new IllegalArgumentException("unknown service class");
    Service svc=(Service)Class.forName(className, true, plugin.classLoader).newInstance();
    if (instanceName!=null)
      svc.setServiceInstanceName(instanceName);
    if (cfg!=null)
      svc.setServiceConfigMap(cfg);
    plugin.addInstance(svc);
    Mundo.registerService(svc);
    return DoObject._base_of(svc);
  }
  /**
   * 
   */
  public void resumeService(TypedMap map) throws Exception
  {
    String className = map.getString("className");
    log.info("resuming: " + className);

    String pluginName = map.getString("pluginName", null);
    if (pluginName != null)
    {
      if (conf.pluginDirectory == null)
        throw new IOException("no plugin directory configured");
      if (!checkFilename(pluginName))
        throw new IllegalArgumentException("filename contains illegal characters");
      boolean download = false;
      Plugin p = getPluginByFN(pluginName);
      if (p == null)
      {
        log.fine("plugin " + pluginName + " not present");
        download = true;
      }
      else
      {
        if (p.getDigest().equals(map.getGUID("pluginDigest")))
        {
          log.fine("plugin " + pluginName + ": digest matches");
        }
        else
        {
          log.fine("plugin " + pluginName + ": digest does not match");
          download = true;
          log.info("deleting: " + pluginName);
          new File(conf.pluginDirectory+'/'+pluginName).delete();
          try
          {
            for (int i=0; i<30; i++)
            {
              p = getPluginByFN(pluginName);
              if (p == null)
                break;
              Thread.sleep(100);
            }
          }
          catch(InterruptedException x) {}
          if (p!=null)
          {
            log.severe("could not unload plugin: " + pluginName);
            throw new IllegalStateException("could not unload plugin: " + pluginName);
          }
        }
      }
      if (download)
      {
        log.fine("download: " + pluginName);
        DoIServiceManager svcMan = new DoIServiceManager(
            session.getChannel("lan", map.getGUID("sourceNodeId")+".ServiceManager"));
        Blob b = svcMan.downloadFile(pluginName);
        FileOutputStream fos = new FileOutputStream(conf.pluginDirectory + "/" + pluginName);
        fos.write(b.getBuffer());
        fos.close();
      }
    }
    
    Plugin plugin = null;
    // If the plugin was just downloaded, it will take some time until it gets loaded.
    // FIXME: There should be a better solution to do this waiting.
    try
    {
      for (int i=0; i<30; i++)
      {
        plugin = (Plugin)plugins.get(className);
        if (plugin != null)
          break;
        Thread.sleep(100);
      }
    }
    catch(InterruptedException x) {}
    if (plugin == null)
    {
      log.severe("plug-in not found for service: " + className);
      throw new IllegalArgumentException("unknown service class: " + className);
    }
    Service svc = (Service)Class.forName(className, true, plugin.classLoader).newInstance();
    plugin.addInstance(svc);
    Mundo.registerMovedService(svc);
    svc.resume(map);
//    return DoObject._base_of(svc);
  }
  /**
   * Uploads a plugin into the plugins directory.
   * @see  IServiceManager
   */
  public void uploadFile(String filename, Blob content) throws IOException
  {
    if (conf.pluginDirectory==null)
      throw new IOException("no plugin directory configured");
    if (!checkFilename(filename))
      throw new IllegalArgumentException("filename contains illegal characters");
    
    String an = conf.pluginDirectory+'/'+filename;
    log.info("upload: "+an);
    FileOutputStream fos = new FileOutputStream(an);
    fos.write(content.getBuffer());
    fos.close();
  }
  /**
   * Downloads a plugin from the plugins directory.
   * @see  IServiceManager
   */
  public Blob downloadFile(String filename) throws IOException
  {
    if (conf.pluginDirectory==null)
      throw new IOException("no plugin directory configured");
    if (!checkFilename(filename))
      throw new IllegalArgumentException("filename contains illegal characters");
    
    String an = conf.pluginDirectory+'/'+filename;
    log.info("download: "+an);
    FileInputStream fis = new FileInputStream(an);
    Blob blob = new Blob();
    blob.readFrom(fis);
    fis.close();
    return blob;
  }
  /**
   * Deletes a plugin from the plugins directory.
   * @see  IServiceManager
   */
  public void deleteFile(String filename) throws IOException
  {
    if (conf.pluginDirectory==null)
      throw new IOException("no plugin directory configured");
    if (!checkFilename(filename))
      throw new IllegalArgumentException("filename contains illegal characters");

    String an=conf.pluginDirectory+'/'+filename;
    log.info("deleting: "+an);
    new File(an).delete();
  }

  private boolean checkFilename(String filename)
  {
    int i, l=filename.length();
    for (i=0; i<l; i++)
    {
      char c=filename.charAt(i);
      if (c<32 || c=='\\' || c=='/' || c==':' || c=='*' || c=='?' || c=='\"' ||
          c=='<' || c=='>' || c=='|')
        return false;
    }
    return true;
  }

  public String getNamespaceURI() // IPluginMonitor.IPluginHandler
  {
    return "http://mundo.org/2004/plugin/service";
  }
  public void pluginRegistered(String uri, Node rootNode, JarFile jar, ClassLoader classLoader) // IPluginMonitor.IPluginHandler
  {
    LOG.fine("pluginRegistered: "+rootNode.getNodeName());
    Metaclass.loadFrom(classLoader);

    Node n=rootNode.getFirstChild();
    Plugin plugin=null;
    while (n!=null)
    {
      if (n.getNodeType()==n.ELEMENT_NODE)
      {
        if ("classname".equals(n.getNodeName()))
        {
          String className=n.getFirstChild().getNodeValue();
          plugin = (Plugin)plugins.get(className);
          if (plugin==null)
          {
            String fn=jar.getName();
            int i = fn.lastIndexOf('/');
            if (i>0)
              fn = fn.substring(i+1);
            i = fn.lastIndexOf('\\');
            if (i>0)
              fn = fn.substring(i+1);
            plugin = new Plugin(className, classLoader, fn);
            plugins.put(className, plugin);
          }
          LOG.fine("classname: "+className);
        }
        else if ("new-instance".equals(n.getNodeName()))
        {
          if (plugin==null)
          {
            log.severe("<classname> must be specified before <new-instance>");
          }
          else try
          {
            OptNewInstance cni = (OptNewInstance)
                node2object(n, getClass().getName()+"$ConfNewInstance", classLoader);
            LOG.fine("new-instance: name="+cni.name);
            Service svc=null;
            try {
              svc=(Service)Class.forName(plugin.className, true, classLoader).newInstance();
            }
            catch(ClassCastException x)
            {
              log.severe(x.toString()+" - is the class to instantiate instanceof Service?");
            }
            if(svc!=null) {
              if (cni.name!=null)
                svc.setServiceInstanceName(cni.name);
              if (cni.config!=null)
                svc.setServiceConfig(cni.config);
              plugin.addInstance(svc);
              Mundo.registerService(svc);
            }
          }
          catch(Throwable x)
          {
            x.printStackTrace();
            log.exception(x);
          }
        }
      }
      n=n.getNextSibling();
    }
  }
  public void pluginUnRegistered(String uri, Node rootNode) // IPluginMonitor.IPluginHandler
  {
    LOG.fine("pluginUnRegistered: "+rootNode.toString());

    String className=null;
    Node n=rootNode.getFirstChild();
    while (n!=null)
    {
      if (n.getNodeType()==n.ELEMENT_NODE && "classname".equals(n.getNodeName()))
      {
        className=n.getFirstChild().getNodeValue();
        LOG.fine("classname: "+className);
        break;
      }
      n=n.getNextSibling();
    }

    if (className==null)
    {
      log.severe("can't parse configuration in pluginUnRegistered");
      return;
    }
    Plugin plugin = (Plugin)plugins.get(className);
    if (plugin==null)
    {
      log.severe("can't find plugin object in pluginUnRegistered");
      return;
    }
    try
    {
      plugin.shutdownInstances();
    }
    catch(Exception x)
    {
      log.exception(x);
    }
    plugins.remove(className);
  }
  /**
   * Parses the specified DOM node and activates the contained object structure.
   */
  private Object node2object(Node n, String className, ClassLoader classLoader) throws Exception
  {
    XMLDeserializer deser=new XMLDeserializer();
    TypedMap p=deser.deserializeMap(n);
    p.setActiveClassName(className);
    TypedMap cfg=p.getMap("config", null);

#ifdef CFG_ANDROID
    String hostName="android";
#else
    String hostName=InetAddress.getLocalHost().getHostName().toLowerCase();
#endif
    int i=hostName.indexOf('.');
    if (i>0)
      hostName=hostName.substring(0, i);
    TypedMap hostCfg=p.getMap("config."+hostName, null);
    if (hostCfg!=null)
    {
      LOG.fine("new-instance: using config for "+hostName);
      if (cfg!=null)
        cfg.putAll(hostCfg);
      else
        p.put("config", hostCfg);
    }
    else
    {
      LOG.fine("new-instance: using default config");
    }

    TypedMap ctx=new TypedMap();
    ctx.put("classLoader", classLoader);
    return TypedContainer.activate(p, ctx);
  }

  public class Plugin
  {
    Plugin(String cn, ClassLoader cl, String pn)
    {
      className=cn;
      classLoader=cl;
      pluginName=pn;
    }
    void addInstance(Service svc)
    {
      synchronized(instances)
      {
        instances.add(svc);
      }
      synchronized(service2plugin)
      {
        service2plugin.put(svc, this);
      }
    }
    void removeInstance(Service svc)
    {
      synchronized(instances)
      {
        instances.remove(svc);
      }
      synchronized(service2plugin)
      {
        service2plugin.remove(svc);
      }
    }
    void shutdownInstances()
    {
#ifdef CFG_JAVA15
      ArrayList<Service> list = instances;
      instances = new ArrayList<Service>();
      for (Service s : list)
        Mundo.unregisterService(s);
#else
      ArrayList list = instances;
      instances = new ArrayList();
      for (Iterator iter = list.iterator(); iter.hasNext();)
        Mundo.unregisterService((Service)iter.next());
#endif
    }
    public String getPathname()
    {
      if (conf.pluginDirectory != null)
        return conf.pluginDirectory + "/" + pluginName;
      else
        return pluginName;
    }
    public String getFilename()
    {
      return pluginName;
    }
    @Override
    public String toString()
    {
      return "pluginName="+pluginName+",className="+className+",classLoader="+classLoader;
    }
    public GUID getDigest() throws IOException
    {
      try
      {
        MessageDigest md = MessageDigest.getInstance("SHA");
        FileInputStream fis = new FileInputStream(getPathname());
        byte[] buffer = new byte[4096];
        int n;
        while ((n = fis.read(buffer)) > 0)
          md.update(buffer, 0, n);
        fis.close();
        byte[] b = new byte[16];
        System.arraycopy(md.digest(), 0, b, 0, 16);
        return new GUID(b);
      }
      catch(Exception x)
      {
        log.exception(x);
        throw new IOException("can't calculate digest", x);
      }
    }

    String className;
    ClassLoader classLoader;
    String pluginName;
#ifdef CFG_JAVA15
    ArrayList<Service> instances = new ArrayList<Service>();
#else
    ArrayList instances = new ArrayList();
#endif
  }
#endif

#ifdef CFG_JAVA15
  /**
   * Starts a service inquiry as continuous query.
   * The services to search for are specified using the filter parameter.
   * The query function returns immediately. For that reason, the returned result
   * set will not immediately contain the complete search result.
   * Always when the result set is updated, the specified handler is notified.
   * When the application is no longer interested in updates, it calls the
   * the <code>release()</code> method. The following example shows how to
   * create a continuous query:
   *
   * <pre>
   * ServiceInfoFilter filter = new ServiceInfoFilter();
   * ServiceManager.getInstance().contQuery(filter, session, new ResultSet.ISignal() {
   *   public void updated(final ResultSet rs, int offset, int oldCount, int newCount) {
   *     System.out.println(rs);
   *   }
   * });
   * </pre>
   *
   * @param sif  a filter object that will be matched with the service descriptions.
   * @param session  the target session. The session will be used to bind
   *   the object references contained in the returned <code>ServiceInfo</code>
   *   objects. If the object references are not needed, session can be set <code>null</code>.
   * @param handler  a handler that will be notified every time the result set changes.
   * @return  a result set containing the <code>ServiceInfo</code> descriptions of the
   *   services found.
   */
  public ResultSet contQuery(ServiceInfoFilter sif, Session session, ResultSet.ISignal handler) throws Exception
  {
    LOG.fine("contQuery: "+sif);
    ResultSet rs = new ResultSet(session);
    if (handler!=null)
      Signal.connect(ResultSet.ISignal.class, rs, handler);
    TypedMapFilter filter = sif._getFilter();
    rs.setFilter(filter);
    TypedMapFilter tmf = new TypedMapFilter();
    tmf.putMapFilter("object", filter);
    Subscriber sub = ContentSubscription.subscribe(session, tmf);
    sub.setReceiver(rs);
    sub.enable();

    if (doAllSvcMan == null)
    {
      doAllSvcMan = new DoIServiceManager();
      Signal.connect(doAllSvcMan, getSession().publish("lan", "lan.sd"));
    }
    doAllSvcMan.advertiseServices(DoObject.ONEWAY_MULTICAST);
    advertiseServices();

    return rs;
  }

  /**
   * Starts a service inquiry as simple query.
   * The services to search for are specified using
   * the filter parameter. The query function returns immediately. For that
   * reason, the returned result set will not immediately contain the complete
   * search result. The application determines when to end the search by calling
   * the <code>release()</code> method. The following example shows how to
   * use the query function and how to terminate search after three seconds:
   *
   * <pre>
   * ServiceInfoFilter filter = new ServiceInfoFilter();
   * ResultSet result = ServiceManager.getInstance().query(filter, session);
   * Thread.sleep(3000);
   * result.release();
   * </pre>
   *
   * @param sif  a filter object that will be matched with the service descriptions.
   * @param session  the target session. The session will be used to bind
   *   the object references contained in the returned <code>ServiceInfo</code>
   *   objects. If the object references are not needed, session can be set <code>null</code>.
   * @return  a result set containing the <code>ServiceInfo</code> descriptions of the
   *   services found.
   */
  public ResultSet query(ServiceInfoFilter sif, Session session) throws Exception
  {
    LOG.fine("query: "+sif);
    ResultSet rs = new ResultSet(session);
    TypedMapFilter filter = sif._getFilter();
    rs.setFilter(filter);
    TypedMapFilter tmf = new TypedMapFilter();
    tmf.putMapFilter("object", filter);
    Subscriber sub = ContentSubscription.subscribe(getSession(), tmf);
    sub.setReceiver(rs);
    sub.enable();

    if (doAllSvcMan == null)
    {
      doAllSvcMan = new DoIServiceManager();
      Signal.connect(doAllSvcMan, getSession().publish("lan", "lan.sd"));
    }
    doAllSvcMan.advertiseServices(DoObject.ONEWAY_MULTICAST);
    advertiseServices();

    return rs;
  }

  /**
   * Used internally. Triggers the service manager to advertise all
   * its services to the network.
   * @see  IServiceManager
   */
  public void advertiseServices()
  {
    LOG.fine("advertiseServices");
    LOG.finest("+advertiseServices");
    for (Service s : services)
      advertiseService(s, ServiceInfo.UPDATE_ADVERTISE);
    LOG.finest("-advertiseServices");
  }

  /**
   * Receives property change events from services.
   */
  public synchronized void propChanging(Service svc) // Service.IProp
  {
    LOG.fine("propChanging: "+svc);
    if (!services.contains(svc))
      return;
    propChangeMap.put(svc.getServiceId(), getServiceInfo(svc));
  }

  /**
   * Receives property change events from services.
   */
  public synchronized void propChanged(Service svc) // Service.IProp
  {
    LOG.fine("propChanged: "+svc);
    if (!services.contains(svc))
      return;

    ServiceInfo oldSI = propChangeMap.get(svc.getServiceId());
    if (oldSI==null)
      return;
    ServiceInfo newSI = getServiceInfo(svc);
    if (oldSI.zone==null && newSI.zone==null)
      return;
    oldSI.update = ServiceInfo.UPDATE_PROPCHANGING;
    newSI.update = ServiceInfo.UPDATE_PROPCHANGED;

    if (discoveryPub == null)
    {
      discoveryPub = ContentSubscription.publish(getSession());
      discoveryPub.enableLocalLoopback(true);
    }

    TypedMap map = new TypedMap();
    map.put("object", oldSI);
    map.put("newObject", newSI);
    discoveryPub.send(new Message(map));

    map = new TypedMap();
    map.put("oldObject", oldSI);
    map.put("object", newSI);
    discoveryPub.send(new Message(map));
  }

  private ServiceInfo getServiceInfo(Service s)
  {
    ServiceInfo si = new ServiceInfo();
    // If the service visibility is 'rt', then create a DoObject with only
    // a local object reference, because
    // - we do not want to expose the service interface to external parties
    // - we do not want the DoObject to be cached in the session. Also the
    //   current session implementation does not distinguish between zones.
    //   Thus, this would lead to problems when the service zone is changed later.
    if ("rt".equals(s.getServiceZone()))
      si.doService = DoObject._base_of(null, s);
    else
      si.doService = DoObject._base_of(s);
    si.guid = s.getServiceId();
    si.className = s.getClass().getName();
    si.instanceName = s.getServiceInstanceName();
    si.zone = s.getServiceZone();
    si.interfaces = new ActiveMap();
    si.superClasses = new ActiveMap();
    si.userData = s.getServiceInfoUserData();

    int hierarchyLevel = 0;
    Class currClass = s.getClass();
    do {
      for (Class ifc : gatherInterfaces(currClass.getInterfaces()))
        si.interfaces.putBoolean(ifc.getName(), true);
      if (hierarchyLevel > 0)
        si.superClasses.putInt(currClass.getName(), hierarchyLevel);
      hierarchyLevel++;
    } while ((currClass = currClass.getSuperclass()) != null);
    si.nodeId = Mundo.getNodeId();
    si.nodeName = Mundo.getNodeName();
    return si;
  }

  private ArrayList<Class> gatherInterfaces(Class[] ifcs)
  {
    ArrayList<Class> allIfcs = new ArrayList<Class>();
    for (Class ifc : ifcs)
    {
      allIfcs.add(ifc);
      allIfcs.addAll(gatherInterfaces(ifc.getInterfaces()));
    }
    return allIfcs;
  }

  private void advertiseService(Service s, int upd)
  {
    String zone = s.getServiceZone();
    if (zone == null)
      return;
    LOG.finer("advertiseService: "+s);
    ServiceInfo si = getServiceInfo(s);
    si.update = upd;
    if ("rt".equals(zone))
    {
      if (localDiscoveryPub == null)
      {
        localDiscoveryPub = ContentSubscription.publish(getSession(), "rt");
        localDiscoveryPub.enableLocalLoopback(true);
      }
      localDiscoveryPub.send(Message.fromObject(si));
    }
    else
    {
      if (discoveryPub == null)
      {
        discoveryPub = ContentSubscription.publish(getSession());
        discoveryPub.enableLocalLoopback(true);
      }
      discoveryPub.send(Message.fromObject(si));
    }
  }
#else
  /**
   * Receives property change events from services.
   */
  public void propChanging(Service svc) // Service.IProp
  {
    LOG.fine("propChanging not supported by this build");
  }

  /**
   * Receives property change events from services.
   */
  public void propChanged(Service svc) // Service.IProp
  {
    LOG.fine("propChanged not supported by this build");
  }
#endif

  public Plugin getPlugin(Service svc)
  {
    return service2plugin.get(svc);
  }
  public Plugin getPluginByFN(String fn)
  {
    for (Plugin p : plugins.values())
      if (fn.equals(p.getFilename()))
        return p;
    return null;
  }

#ifdef CFG_JAVA15
  CopyOnWriteArrayList<Service> services;
  HashMap<String,Plugin> plugins = new HashMap<String,Plugin>();
  HashMap<Service,Plugin> service2plugin = new HashMap<Service,Plugin>();
  HashMap<GUID,ServiceInfo> propChangeMap = new HashMap<GUID,ServiceInfo>();
  DoIServiceManager doAllSvcMan = null;
  Publisher discoveryPub = null;
  Publisher localDiscoveryPub = null;
#else
#ifndef CFG_J2ME
  ArrayList services;
  HashMap plugins = new HashMap();
  HashMap service2plugin = new HashMap();
#else
  TypedArray services;
#endif
#endif
  private static ServiceManager singleton;
  OptServiceManager conf;
  Logger log = Logger.getLogger("svcman");
}
