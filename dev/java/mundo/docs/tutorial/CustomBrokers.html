<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
<title> CustomBrokers &lt; Mundo &lt; Foswiki</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="icon" href="/foswiki/pub/System/ProjectLogos/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="/foswiki/pub/System/ProjectLogos/favicon.ico" type="image/x-icon" />
<link rel="alternate" href="http://127.0.0.1/foswiki/bin/edit/Mundo/CustomBrokers?t=1295995550" type="application/x-wiki" title="edit CustomBrokers" />
<meta name="TEXT_NUM_TOPICS" content="Number of topics:" />
<meta name="TEXT_MODIFY_SEARCH" content="Modify search" />
<meta name="robots" content="noindex" /><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/foswiki/bin/view/Mundo/WebRss" />
<style type="text/css" media="all">
@import url('style/base.css');
</style>
<style type="text/css" media="all">
@import url('style/layout.css');
@import url('style/style.css');
@import url('style/colors.css');
</style>
<style type="text/css" media="all">
@import url('style/column_left.css');
@import url('style/variant_foswiki_noframe.css');
</style><style type="text/css" media="all">
	/* Styles that are set using variables */
	.patternBookView .foswikiTopRow,
	.patternWebIndicator a img,
	.patternWebIndicator a:hover img {
		background-color:#efefef;
	}
	#patternTopBarContents { background-image:url(/foswiki/pub/System/PatternSkin/header5.gif); background-repeat:repeat-x;}
#patternTopBarContents { background-color:#ffffff;}
.patternBookView {
	border-color:#efefef;
}
.patternPreviewPage #patternMain {
	/* uncomment to set the preview image */
	/*background-image:url("/foswiki/pub/System/PreviewBackground/preview2bg.gif");*/
}
</style>
<style type="text/css" media="all">
@import url('style/print.css');
</style>
<!--[if IE]><style type="text/css" media="screen">
pre {
	height:1%;
	overflow-x:auto;
}
.foswikiAttachments,
.foswikiForm,
.foswikiHelp,
.foswikiPreviewArea,
.patternPreviewPage .foswikiForm,
.patternSigLine,
.patternToolBar,
.patternTop,
.patternTopicAction,
#patternSideBarContents .patternLeftBarPersonal,
#patternSideBarContents h2,
#patternSideBarContents li,
#patternTopBarButtons ul {
	height:1%;
}
#patternSideBarContents .patternLeftBarPersonal {
	width:100%;
}
.foswikiFormStep {
	height:100%;
}
#foswikiLogin,
.patternShadow {
	border:10px solid #fff;
	margin-top:10px;
	margin-bottom:10px;
	border:2px solid #ccc;
}
</style><![endif]-->
<!--[if gt IE 8 ]><style type="text/css" media="screen">
#foswikiLogin,
.patternShadow {
	border:10px solid #fff;
	margin-top:10px;
	margin-bottom:10px;
	box-shadow: 0 0 10px #ccc;
}
</style><![endif]-->
<meta name="foswiki.TWISTYANIMATIONSPEED" content="fast" /><!--TWISTYPLUGIN::META-->
<style type="text/css" media="all">
.foswikiTable {border-width:1px}
.foswikiTable .tableSortIcon img {padding-left:.3em; vertical-align:text-bottom}
.foswikiTable td {border-style:solid none; vertical-align:top}
.foswikiTable th {border-style:none solid; vertical-align:top; background-color:#d6d3cf; color:#000000}
.foswikiTable th a:link {color:#000000}
.foswikiTable th a:visited {color:#000000}
.foswikiTable th a:hover {color:#000000; background-color:#d6d3cf}
.foswikiTable th.foswikiSortedCol {background-color:#c4c1ba}
.foswikiTable tr.foswikiTableRowdataBg0 td {background-color:#ffffff}
.foswikiTable tr.foswikiTableRowdataBg0 td.foswikiSortedCol {background-color:#f7f7f6}
.foswikiTable tr.foswikiTableRowdataBg1 td {background-color:#f7f7f6}
.foswikiTable tr.foswikiTableRowdataBg1 td.foswikiSortedCol {background-color:#f0f0ee}
</style><!--TABLEPLUGIN_default-->
<meta name="foswiki.PUBURL" content="http://127.0.0.1/foswiki/pub" /> <!-- PUBURL -->
<meta name="foswiki.PUBURLPATH" content="/foswiki/pub" /> <!-- PUBURLPATH -->
<meta name="foswiki.SCRIPTSUFFIX" content="" /> <!-- SCRIPTSUFFIX -->
<meta name="foswiki.SCRIPTURL" content="http://127.0.0.1/foswiki/bin" /> <!-- SCRIPTURL -->
<meta name="foswiki.SCRIPTURLPATH" content="/foswiki/bin" /> <!-- SCRIPTURLPATH -->
<meta name="foswiki.SERVERTIME" content="25%20Jan%202011%20-%2023:45" /> <!-- SERVERTIME -->
<meta name="foswiki.SKIN" content="pattern" /> <!-- SKIN -->
<meta name="foswiki.SYSTEMWEB" content="System" /> <!-- SYSTEMWEB -->
<meta name="foswiki.TOPIC" content="CustomBrokers" /> <!-- TOPIC -->
<meta name="foswiki.USERNAME" content="guest" /> <!-- USERNAME -->
<meta name="foswiki.USERSWEB" content="Main" /> <!-- USERSWEB -->
<meta name="foswiki.WEB" content="Mundo" /> <!-- WEB -->
<meta name="foswiki.WIKINAME" content="WikiGuest" /> <!-- WIKINAME -->
<meta name="foswiki.WIKIUSERNAME" content="Main.WikiGuest" /> <!-- WIKIUSERNAME -->
<meta name="foswiki.NAMEFILTER" content="%5b%5cs%5c*%3f~%5e%5c%24%40%25%60%22'%26%3b%7c%3c%3e%5c%5b%5c%5d%23%5cx00-%5cx1f%5d" /> <!-- NAMEFILTER --><!--JQUERYPLUGIN::FOSWIKI::META-->
</head>
<body class="patternViewPage patternPrintPage">
<a name="PageTop"></a><div class="foswikiPage"><div id="patternScreen">
<div id="patternPageShadow">
<div id="patternPage">
<div id="patternOuter">
<div id="patternFloatWrap">
<div id="patternMain">
<div id="patternMainContents">
<div class="patternContent"><div class="foswikiTopic"> <h1><a name="Writing_custom_message_brokers"></a>  Writing custom message brokers </h1>
<p />
The programs described in the following sections can also be found in the <code>samples/handlers</code> subdirectory of the distribution or in the CVS.
<p />
A message broker is a special kind of a protocol handler. Hence, we start by examining the first three steps explained in the section Writing custom protocol handlers.
<p />
The following sections discuss the implementation of a simple broker.
<p />
<h2><a name="Handling_BCLProvider_events"></a>  Handling BCLProvider events </h2>
<p />
A central concept of MundoCore is its communication micro-broker, which is implemented by the Basic Communications Layer Provider (BCLProvider). The BCLProvider implements a channel-based publish/subscribe system that enables local services to communicate with each other.
<p />
Message brokers are now responsible for forwarding all non-local messages from the BCLProvider to remote nodes and vice-versa. As a first step, the broker registers for events from the BCLProvider. Whenever a local service subscribes, unsubscribes, advertises, or unadvertises, our new broker will be notified. The following program registers for BCLProvider events and generates log output on such events.
<p />
<p />
<!-- SyntaxHighlightingPlugin --><pre class='syntaxHighlightingPlugin'><B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.IMessageHandler;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Message;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.TypedMap;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Service;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Publisher;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Subscriber;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Signal;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Logger;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.IBCLProvider;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.net.ProtocolCoordinator;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.net.AbstractHandler;

<I><FONT COLOR="#B22222">/**
 * This is the skeleton for a message broker.
 * @author Erwin Aitenbichler
 */</FONT></I>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> DumbTopicBroker
        <B><FONT COLOR="#A020F0">extends</FONT></B> AbstractHandler
        <B><FONT COLOR="#A020F0">implements</FONT></B> IBCLProvider.ISignal {
  <B><FONT COLOR="#A020F0">public</FONT></B> DumbTopicBroker()
  {
  }
  <I><FONT COLOR="#B22222">/**
   * Called on initialization of the service.
   */</FONT></I>
  @Override
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> init() <I><FONT COLOR="#B22222">// Service
</FONT></I>{
    <B><FONT COLOR="#A020F0">super</FONT></B>.init();
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;init&quot;</FONT></B>);
    <I><FONT COLOR="#B22222">// Register our MIME Type with the protocol coordinator
</FONT></I>    ProtocolCoordinator.register(mimeType, <B><FONT COLOR="#A020F0">this</FONT></B>);
  }
  <I><FONT COLOR="#B22222">/**
   * Called on shutdown of the service.
   */</FONT></I>
  @Override
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> shutdown() <I><FONT COLOR="#B22222">// Service
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;shutdown&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">super</FONT></B>.shutdown();
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a packet travels down the stack.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">boolean</FONT></B> down(Message msg) <I><FONT COLOR="#B22222">// IMessageHandler
</FONT></I>  {
    <B><FONT COLOR="#A020F0">try</FONT></B>
    {
      log.fine(<B><FONT COLOR="#BC8F8F">&quot;down: &quot;</FONT></B> + msg);

      <I><FONT COLOR="#B22222">// Add our own header to the message
</FONT></I>      TypedMap hdr = <B><FONT COLOR="#A020F0">new</FONT></B> TypedMap();
      <I><FONT COLOR="#B22222">// Store the current MIME type of the message in our header
</FONT></I>      hdr.putString(<B><FONT COLOR="#BC8F8F">&quot;type&quot;</FONT></B>, msg.getType());
      putHeader(msg, headerChunkName, hdr);

      <I><FONT COLOR="#B22222">// Set our MIME type
</FONT></I>      msg.setType(mimeType);

      <I><FONT COLOR="#B22222">// Pass the message to the next lower handler
</FONT></I>      <B><FONT COLOR="#A020F0">return</FONT></B> emit_down(msg);
    }
    <B><FONT COLOR="#A020F0">catch</FONT></B>(Exception x)
    {
      log.exception(x);
    }
    <I><FONT COLOR="#B22222">// Tell the caller that we dropped the packet
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">false</FONT></B>;
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a packet travels up the stack.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">boolean</FONT></B> up(Message msg) <I><FONT COLOR="#B22222">// IMessageHandler
</FONT></I>  {
    <B><FONT COLOR="#A020F0">try</FONT></B>
    {
      log.fine(<B><FONT COLOR="#BC8F8F">&quot;up: &quot;</FONT></B> + msg);

      <I><FONT COLOR="#B22222">// Get our header
</FONT></I>      TypedMap hdr = getHeader(msg, headerChunkName);
      <I><FONT COLOR="#B22222">// Restore the previous MIME type
</FONT></I>      msg.setType(hdr.getString(<B><FONT COLOR="#BC8F8F">&quot;type&quot;</FONT></B>));

      <B><FONT COLOR="#A020F0">return</FONT></B> emit_up(msg);
    }
    <B><FONT COLOR="#A020F0">catch</FONT></B>(Exception x)
    {
      log.exception(x);
    }
    <I><FONT COLOR="#B22222">// Tell the caller that we dropped the packet
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">false</FONT></B>;
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a new subscriber is added by a local service.
   * @param s  the subscriber object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> subscriberAdded(Subscriber s) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;subscriberAdded: &quot;</FONT></B>+s);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a subscriber is removed by a local service.
   * @param s  the subscriber object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> subscriberRemoved(Subscriber s) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;subscriberRemoved: &quot;</FONT></B>+s);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a new publisher is added by a local service.
   * @param p  the publisher object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> publisherAdded(Publisher p) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;publisherAdded: &quot;</FONT></B>+p);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a publisher is removed by a local service.
   * @param p  the publisher object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> publisherRemoved(Publisher p) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;publisherRemoved: &quot;</FONT></B>+p);
  }
  
  <B><FONT COLOR="#A020F0">private</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> String headerChunkName = <B><FONT COLOR="#BC8F8F">&quot;dumbtb&quot;</FONT></B>;
  <B><FONT COLOR="#A020F0">private</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> String mimeType = <B><FONT COLOR="#BC8F8F">&quot;message/dumbtb&quot;</FONT></B>;
  <B><FONT COLOR="#A020F0">private</FONT></B> Logger log = Logger.getLogger(<B><FONT COLOR="#BC8F8F">&quot;dumbtb&quot;</FONT></B>);
}</pre><!-- end SyntaxHighlightingPlugin -->
<p />
<h2><a name="Forwarding_messages"></a>  Forwarding messages </h2>
<p />
The following program shows how to implement a simple channel-based publish/subscribe broker. This broker does not perform any filtering and simply forwards all messages from local services to all remote nodes. Hence, this broker is simple, but totally inefficient.
<p /> <ul>
<li> The broker makes a wildcard subscription to receive all local messages (in <code>init</code>).
</li> <li> When a local message is received, it adds a parameter chunk to the message. This is necessary to access the name of the target channel later on. The message is then passed to the <span class="foswikiNewLink">ProtocolCoordinator<a href="/foswiki/bin/edit/Mundo/ProtocolCoordinator?topicparent=Mundo.CustomBrokers" rel="nofollow" title="Create this topic">?</a></span> to process the protocol handler chain between application and broker (in <code>received</code>).
</li> <li> The broker broadcasts all received messages to the current zone, i.e., typically all discovered peers (in <code>down</code>).
</li> <li> When a message is received from a remote peer, the address chunk must be reconstructed (in <code>up</code>).
</li></ul> 
<p />
<p />
<!-- SyntaxHighlightingPlugin --><pre class='syntaxHighlightingPlugin'><B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.net.AbstractHandler;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.net.ProtocolCoordinator;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.IBCLProvider;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.IMessageHandler;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.IReceiver;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Logger;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Message;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.MessageContext;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Publisher;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Service;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Signal;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.Subscriber;
<B><FONT COLOR="#A020F0">import</FONT></B> org.mundo.rt.TypedMap;

<I><FONT COLOR="#B22222">/**
 * This is the skeleton for a message broker.
 * @author Erwin Aitenbichler
 */</FONT></I>
<B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">class</FONT></B> DumbTopicBroker
        <B><FONT COLOR="#A020F0">extends</FONT></B> AbstractHandler
        <B><FONT COLOR="#A020F0">implements</FONT></B> IBCLProvider.ISignal, IReceiver
{
  <B><FONT COLOR="#A020F0">public</FONT></B> DumbTopicBroker()
  {
  }
  <I><FONT COLOR="#B22222">/**
   * Called on initialization of the service.
   */</FONT></I>
  @Override
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> init() <I><FONT COLOR="#B22222">// Service
</FONT></I>  {
    <B><FONT COLOR="#A020F0">super</FONT></B>.init();
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;init&quot;</FONT></B>);
    <I><FONT COLOR="#B22222">// Register our MIME Type with the protocol coordinator
</FONT></I>    ProtocolCoordinator.register(mimeType, <B><FONT COLOR="#A020F0">this</FONT></B>);
    <I><FONT COLOR="#B22222">// Receive all local messages
</FONT></I>    session.subscribe(<B><FONT COLOR="#BC8F8F">&quot;rt&quot;</FONT></B>, <B><FONT COLOR="#A020F0">null</FONT></B>, <B><FONT COLOR="#A020F0">this</FONT></B>);
  }
  <I><FONT COLOR="#B22222">/**
   * Called on shutdown of the service.
   */</FONT></I>
  @Override
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> shutdown() <I><FONT COLOR="#B22222">// Service
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;shutdown&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">super</FONT></B>.shutdown();
  }
  <I><FONT COLOR="#B22222">/**
   * Receives all local messages. Messages are forwarded to the topmost
   * protocol handler in the protocol stack.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> received(Message msg, MessageContext c) <I><FONT COLOR="#B22222">// IReceiver
</FONT></I>  {
    msg = msg.copyFrame();
    TypedMap pmap = <B><FONT COLOR="#A020F0">new</FONT></B> TypedMap();
    pmap.putString(<B><FONT COLOR="#BC8F8F">&quot;channel&quot;</FONT></B>, c.channel.getName());
    msg.put(headerChunkName, <B><FONT COLOR="#BC8F8F">&quot;param&quot;</FONT></B>, pmap);
    ProtocolCoordinator.getInstance().firstDown(msg);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a packet travels down the stack.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">boolean</FONT></B> down(Message msg) <I><FONT COLOR="#B22222">// IMessageHandler
</FONT></I>  {
    TypedMap param = msg.getMap(headerChunkName, <B><FONT COLOR="#BC8F8F">&quot;param&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (param==<B><FONT COLOR="#A020F0">null</FONT></B>)
    {
      log.warning(<B><FONT COLOR="#BC8F8F">&quot;no &quot;</FONT></B>+headerChunkName+<B><FONT COLOR="#BC8F8F">&quot; parameter in message&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">false</FONT></B>;
    }
    String channel = param.getString(<B><FONT COLOR="#BC8F8F">&quot;channel&quot;</FONT></B>);
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;down: channel=&quot;</FONT></B>+channel);

    <I><FONT COLOR="#B22222">// Add our own header to the message
</FONT></I>    msg = msg.copyFrame();
    TypedMap hdr = <B><FONT COLOR="#A020F0">new</FONT></B> TypedMap();
    hdr.putString(<B><FONT COLOR="#BC8F8F">&quot;channel&quot;</FONT></B>, channel);
    msg.put(headerChunkName, <B><FONT COLOR="#BC8F8F">&quot;passive&quot;</FONT></B>, hdr);

    <I><FONT COLOR="#B22222">// Set our MIME type
</FONT></I>    msg.setType(mimeType);

    <I><FONT COLOR="#B22222">// Create a parameter chunk for the routing service and define the whole
</FONT></I>    <I><FONT COLOR="#B22222">// zone as destination for the message
</FONT></I>    TypedMap rs = <B><FONT COLOR="#A020F0">new</FONT></B> TypedMap();
    rs.putString(<B><FONT COLOR="#BC8F8F">&quot;destType&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;zone&quot;</FONT></B>);
    msg.put(<B><FONT COLOR="#BC8F8F">&quot;rs&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;param&quot;</FONT></B>, rs);

    <I><FONT COLOR="#B22222">// Pass the message to the next lower handler
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> emit_down(msg);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a packet travels up the stack.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">boolean</FONT></B> up(Message msg) <I><FONT COLOR="#B22222">// IMessageHandler
</FONT></I>  {
    <I><FONT COLOR="#B22222">// Get our header
</FONT></I>    TypedMap hdr = msg.getMap(headerChunkName, <B><FONT COLOR="#BC8F8F">&quot;passive&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (hdr==<B><FONT COLOR="#A020F0">null</FONT></B>)
    {
      log.warning(<B><FONT COLOR="#BC8F8F">&quot;no &quot;</FONT></B>+headerChunkName+<B><FONT COLOR="#BC8F8F">&quot; header in message&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">return</FONT></B> <B><FONT COLOR="#A020F0">false</FONT></B>;
    }
    String channel = hdr.getString(<B><FONT COLOR="#BC8F8F">&quot;channel&quot;</FONT></B>);
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;up: channel=&quot;</FONT></B>+channel);
    <I><FONT COLOR="#B22222">// Reconstruct the address chunk
</FONT></I>    TypedMap amap = msg.getOrCreateMap(<B><FONT COLOR="#BC8F8F">&quot;address&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;passive&quot;</FONT></B>);
    amap.put(<B><FONT COLOR="#BC8F8F">&quot;channel&quot;</FONT></B>, channel);
    <I><FONT COLOR="#B22222">// Also put the session of this broker into the address chunk. This will
</FONT></I>    <I><FONT COLOR="#B22222">// prevent that the message will be looped back to us
</FONT></I>    amap.put(<B><FONT COLOR="#BC8F8F">&quot;session&quot;</FONT></B>, session);
    <B><FONT COLOR="#A020F0">return</FONT></B> emit_up(msg);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a new subscriber is added by a local service.
   * @param s  the subscriber object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> subscriberAdded(Subscriber s) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;subscriberAdded: &quot;</FONT></B>+s);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a subscriber is removed by a local service.
   * @param s  the subscriber object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> subscriberRemoved(Subscriber s) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;subscriberRemoved: &quot;</FONT></B>+s);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a new publisher is added by a local service.
   * @param p  the publisher object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> publisherAdded(Publisher p) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;publisherAdded: &quot;</FONT></B>+p);
  }
  <I><FONT COLOR="#B22222">/**
   * Called when a publisher is removed by a local service.
   * @param p  the publisher object.
   */</FONT></I>
  <B><FONT COLOR="#A020F0">public</FONT></B> <B><FONT COLOR="#A020F0">void</FONT></B> publisherRemoved(Publisher p) <I><FONT COLOR="#B22222">// IBCLProvider.ISignal
</FONT></I>  {
    log.fine(<B><FONT COLOR="#BC8F8F">&quot;publisherRemoved: &quot;</FONT></B>+p);
  }
  
  <B><FONT COLOR="#A020F0">private</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> String headerChunkName = <B><FONT COLOR="#BC8F8F">&quot;dumbtb&quot;</FONT></B>;
  <B><FONT COLOR="#A020F0">private</FONT></B> <B><FONT COLOR="#A020F0">static</FONT></B> <B><FONT COLOR="#A020F0">final</FONT></B> String mimeType = <B><FONT COLOR="#BC8F8F">&quot;message/dumbtb&quot;</FONT></B>;
  <B><FONT COLOR="#A020F0">private</FONT></B> Logger log = Logger.getLogger(<B><FONT COLOR="#BC8F8F">&quot;dumbtb&quot;</FONT></B>);
}</pre><!-- end SyntaxHighlightingPlugin -->
<p />
</div></div><!-- /patternContent-->
</div></div></div></div></div></div></div></div>
</body></html>
